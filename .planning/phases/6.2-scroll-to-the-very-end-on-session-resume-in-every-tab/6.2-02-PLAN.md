---
phase: 6.2-scroll-to-the-very-end-on-session-resume-in-every-tab
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - renderer.js
  - src/renderer/ui/components/TerminalManager.js
autonomous: true
gap_closure: true
requirements:
  - SESS-01
must_haves:
  truths:
    - "Restored terminal tabs scroll to the very bottom after all session history has arrived — no race with PTY data stream"
    - "Resumed Claude sessions scroll to bottom after the ✳ OSC title fires AND the PTY data stream goes silent"
    - "Chat-mode tabs produce no scroll errors (null terminal guard still in place)"
    - "Non-active restored tabs also scroll to bottom when the user switches to them"
  artifacts:
    - path: "src/renderer/ui/components/TerminalManager.js"
      provides: "scheduleScrollAfterRestore(id) — exported function encapsulating silence-based scroll"
      exports: ["scheduleScrollAfterRestore"]
      contains: "scheduleScrollAfterRestore"
    - path: "renderer.js"
      provides: "Post-restore loop calls scheduleScrollAfterRestore per tab instead of fixed setTimeout"
      contains: "scheduleScrollAfterRestore"
  key_links:
    - from: "renderer.js restore loop"
      to: "TerminalManager.scheduleScrollAfterRestore(id)"
      via: "called once per restored tab id after createTerminal/createChatTerminal"
      pattern: "scheduleScrollAfterRestore"
    - from: "scheduleScrollAfterRestore"
      to: "lastTerminalData Map"
      via: "setInterval polling — 300ms silence or 8s hard fallback triggers scrollToBottom"
      pattern: "lastTerminalData.get\\(id\\)"
    - from: "src/renderer/ui/components/TerminalManager.js updateTerminalStatus"
      to: "scheduleScrollAfterRestore"
      via: "loading->ready branch replaced: call scheduleScrollAfterRestore instead of immediate scrollToBottom"
      pattern: "scheduleScrollAfterRestore\\(id\\)"
---

<objective>
Replace the fixed 200ms scroll-after-restore timeout and the premature loading->ready scrollToBottom with silence-based scroll detection that waits for PTY data to stop arriving before issuing scrollToBottom.

Purpose: Both race conditions share the same root cause — no "replay complete" signal exists. The 200ms timer fires before PTY data has finished streaming (unbounded replay size). The loading->ready scroll fires when the ✳ OSC title arrives, which is emitted by Claude before earlier data batches have been flushed to xterm. The fix uses the already-existing lastTerminalData Map in TerminalManager.js to detect when the terminal goes 300ms without new data — a reliable proxy for "replay done" — with an 8-second hard fallback.

Output: A new exported function scheduleScrollAfterRestore(id) in TerminalManager.js that polls lastTerminalData for silence, called from renderer.js (replacing the setTimeout(200) block) and from the updateTerminalStatus loading->ready branch (replacing the immediate scrollToBottom call).
</objective>

<execution_context>
@C:/Users/uhgde/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/uhgde/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@renderer.js
@src/renderer/ui/components/TerminalManager.js
@.planning/debug/scroll-to-bottom-race-condition.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scheduleScrollAfterRestore to TerminalManager and replace premature scroll in updateTerminalStatus</name>
  <files>src/renderer/ui/components/TerminalManager.js</files>
  <action>
**Add scheduleScrollAfterRestore function** — place it immediately before the `module.exports` block at the end of the file:

```javascript
/**
 * Schedule a scroll-to-bottom for a restored terminal once PTY data goes silent.
 *
 * After app restart or --resume, PTY replay streams data through the adaptive batcher
 * (4–32ms per IPC batch) for an unbounded duration proportional to session history size.
 * A fixed timeout cannot reliably cover all sessions. Instead, we poll lastTerminalData
 * (already maintained per terminal) and scroll once 300ms of silence is observed, or
 * after 8s unconditionally.
 *
 * @param {string} id - Terminal ID
 */
function scheduleScrollAfterRestore(id) {
  const SILENCE_MS = 300;   // 300ms no new data = replay done
  const MAX_WAIT_MS = 8000; // hard fallback — scroll regardless after 8s
  const POLL_MS = 50;       // polling interval

  const startTime = Date.now();

  const poll = setInterval(() => {
    const td = getTerminal(id);
    if (!td || !td.terminal || typeof td.terminal.scrollToBottom !== 'function') {
      clearInterval(poll);
      return;
    }

    const lastData = lastTerminalData.get(id);
    const silentFor = lastData ? Date.now() - lastData : Date.now() - startTime;
    const timedOut  = Date.now() - startTime >= MAX_WAIT_MS;

    if (silentFor >= SILENCE_MS || timedOut) {
      clearInterval(poll);
      td.terminal.scrollToBottom();
    }
  }, POLL_MS);
}
```

**Export it** — in the existing `module.exports` block (line ~3736), add `scheduleScrollAfterRestore` to the exported object alongside the other exports:

```javascript
  scheduleScrollAfterRestore,
```

Add it after `updateTerminalTabName` and before `cleanupProjectMaps` (any position inside the object works — place it near the end for minimal diff).

**Replace the premature scrollToBottom in updateTerminalStatus** — in the `loading->ready` branch (around line 1069-1073), the current code is:

```javascript
      // Scroll to bottom after session replay output has been written
      const td = getTerminal(id);
      if (td && td.terminal && typeof td.terminal.scrollToBottom === 'function') {
        td.terminal.scrollToBottom();
      }
```

Replace those four lines with a call to the new function:

```javascript
      // Schedule silence-based scroll — fires 300ms after PTY data goes quiet
      scheduleScrollAfterRestore(id);
```

This eliminates Race 2: instead of scrolling synchronously while earlier IPC batches may still be in-flight, we defer until the data stream is actually silent.
  </action>
  <verify>
    <automated>cd C:\Users\uhgde\source\repos\claude-terminal && npm run build:renderer && npm test</automated>
    <manual>Verify grep: grep -n "scheduleScrollAfterRestore" src/renderer/ui/components/TerminalManager.js should show 3 lines (function definition, the call inside updateTerminalStatus, and the export).</manual>
  </verify>
  <done>scheduleScrollAfterRestore is defined, exported, and called in the loading->ready branch. Build passes. Tests pass. No immediate scrollToBottom remains in the loading->ready branch.</done>
</task>

<task type="auto">
  <name>Task 2: Replace fixed setTimeout(200) in renderer.js with per-tab scheduleScrollAfterRestore calls</name>
  <files>renderer.js</files>
  <action>
In renderer.js, locate the post-restore scroll block (currently around lines 228-236):

```javascript
      // Scroll all restored terminals to bottom after fit completes
      setTimeout(() => {
        const terminals = terminalsState.get().terminals;
        terminals.forEach((td, id) => {
          if (td.terminal && typeof td.terminal.scrollToBottom === 'function') {
            td.terminal.scrollToBottom();
          }
        });
      }, 200);
```

Replace the entire `setTimeout(...)` block with a per-terminal call to `scheduleScrollAfterRestore`:

```javascript
      // Schedule silence-based scroll per restored terminal (waits for PTY replay to finish)
      const { scheduleScrollAfterRestore } = require('./src/renderer/ui/components/TerminalManager');
      terminalsState.get().terminals.forEach((td, id) => {
        if (td.terminal && typeof td.terminal.scrollToBottom === 'function') {
          scheduleScrollAfterRestore(id);
        }
      });
```

This eliminates Race 1: instead of a single 200ms timer shared across all terminals (which fires before data has arrived for sessions with > ~100KB of history), each terminal gets its own silence-based poller that fires only after its own data stream quiets.

Note: The `require` path uses `./src/renderer/...` which matches the existing lazy-require pattern throughout renderer.js (used in Phase 04, 05, 6.1 etc. to avoid circular deps). The `TerminalManager` module is already required at the top of renderer.js — however the `scheduleScrollAfterRestore` symbol was not destructured there initially. Use the lazy require pattern here to avoid modifying the top-level import line and to follow established convention.

Alternatively, if TerminalManager is already imported at the top of renderer.js as a full object (e.g., `const TerminalManager = require('./src/renderer/ui/components/TerminalManager')`), call `TerminalManager.scheduleScrollAfterRestore(id)` using the existing reference — no additional require needed. Check the top of renderer.js: if `TerminalManager` is imported as a named const, use `TerminalManager.scheduleScrollAfterRestore(id)` directly. If it is destructured (only specific methods imported), add `scheduleScrollAfterRestore` to the destructure list at the top.
  </action>
  <verify>
    <automated>cd C:\Users\uhgde\source\repos\claude-terminal && npm run build:renderer && npm test</automated>
    <manual>Verify grep: grep -n "scheduleScrollAfterRestore\|setTimeout.*200" renderer.js — should show scheduleScrollAfterRestore called per tab, and NO setTimeout(200) scroll block. Build and test must pass.</manual>
  </verify>
  <done>renderer.js calls scheduleScrollAfterRestore per restored terminal instead of a shared setTimeout(200). The fixed 200ms block is completely removed. Build passes. Tests pass.</done>
</task>

</tasks>

<verification>
1. `npm run build:renderer` exits 0
2. `npm test` passes all existing test suites
3. `grep -n "scheduleScrollAfterRestore" src/renderer/ui/components/TerminalManager.js` returns 3+ lines (definition, updateTerminalStatus call-site, export)
4. `grep -n "setTimeout.*200" renderer.js` returns no scroll-related match (only other unrelated timeouts if any)
5. `grep -n "scheduleScrollAfterRestore" renderer.js` returns the per-tab call-site
6. No bare `scrollToBottom()` call remains in the loading->ready branch of updateTerminalStatus
</verification>

<success_criteria>
- Restored terminals scroll to bottom only after PTY data has been silent for 300ms (or 8s hard fallback) — no more race with streaming replay data
- Resumed Claude sessions scroll to bottom after the ✳ OSC title AND subsequent data stream silence, not before
- Chat-mode tabs are unaffected (null terminal guard inside scheduleScrollAfterRestore exits early)
- Build and all tests pass
- No fixed 200ms timeout remains in the restore path
</success_criteria>

<output>
After completion, create `.planning/phases/6.2-scroll-to-the-very-end-on-session-resume-in-every-tab/6.2-02-SUMMARY.md`
</output>
