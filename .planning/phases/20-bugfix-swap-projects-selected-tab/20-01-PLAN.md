---
phase: 20-bugfix-swap-projects-selected-tab
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/ui/components/TerminalManager.js
autonomous: true
requirements: []
must_haves:
  truths:
    - "Switching from Project A (on tab 3) to Project B and back to Project A lands on tab 3"
    - "Scroll position in terminal tabs is preserved when switching between projects"
    - "Scroll position in chat tabs is preserved when switching between projects"
    - "If the remembered tab was closed, the first available tab is selected instead"
    - "Fresh projects with no terminals keep existing behavior unchanged"
    - "App restart still uses existing Phase 04/06 disk-based restore logic"
  artifacts:
    - path: "src/renderer/ui/components/TerminalManager.js"
      provides: "In-memory per-project active tab tracking and scroll position restoration"
      contains: "lastActivePerProject"
  key_links:
    - from: "setActiveTerminal()"
      to: "lastActivePerProject Map"
      via: "Map.set on every tab activation"
      pattern: "lastActivePerProject\\.set"
    - from: "filterByProject()"
      to: "lastActivePerProject Map"
      via: "Map.get to find saved tab before disk fallback"
      pattern: "lastActivePerProject\\.get"
    - from: "setActiveTerminal()"
      to: "savedScrollPositions Map"
      via: "Capture outgoing scroll, restore incoming scroll"
      pattern: "savedScrollPositions\\.(set|get)"
---

<objective>
Fix the bug where switching between projects always resets to the first tab instead of remembering the last-active tab. Add in-memory Maps to track the active terminal ID per project and scroll positions per terminal, so switching back to a project restores the exact tab and scroll position the user had.

Purpose: Users lose context when switching projects because the app forgets which tab they were working on.
Output: Modified TerminalManager.js with two module-level Maps and updated setActiveTerminal/filterByProject/closeTerminal functions.
</objective>

<execution_context>
@C:/Users/uhgde/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/uhgde/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-bugfix-swap-projects-selected-tab/20-RESEARCH.md
@src/renderer/ui/components/TerminalManager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add in-memory Maps and wire capture/restore in setActiveTerminal and closeTerminal</name>
  <files>src/renderer/ui/components/TerminalManager.js</files>
  <action>
Add two module-level Maps near the top of TerminalManager.js (near the other module-level Maps like `lastTerminalData`, `terminalContext`, etc.):

```javascript
// Track last-active terminal ID per project (in-memory, within-session only)
const lastActivePerProject = new Map();
// Track scroll position per terminal at leave-time
const savedScrollPositions = new Map();
```

In `setActiveTerminal(id)` (line ~1176), add scroll capture/restore and Map tracking:

**Before the existing blur logic** (after `const prevTermData = ...`):
- Capture scroll position of the outgoing terminal (only if prevActiveId exists and differs from id):
  - For chat mode: query DOM `document.querySelector('.terminal-wrapper[data-id="${prevActiveId}"]')?.querySelector('.chat-messages')` and save its `.scrollTop`
  - For terminal mode: save `prevTermData.terminal.buffer.active.viewportY`
  - Store in `savedScrollPositions.set(prevActiveId, { scrollTop/viewportY })`

**After the existing `if (termData)` block** (after fitAddon.fit/focus and time tracking, around line ~1219, before the Claude tab tracking block):
- Record this terminal as last-active for its project: `if (termData?.project?.id) lastActivePerProject.set(termData.project.id, id);`
- Restore scroll position of the incoming terminal (only if saved entry exists):
  - Use `requestAnimationFrame` to defer until DOM is visible
  - For chat mode: `const wrapper = document.querySelector('.terminal-wrapper[data-id="${id}"]'); const messagesEl = wrapper?.querySelector('.chat-messages'); if (messagesEl) messagesEl.scrollTop = saved.scrollTop;`
  - For terminal mode: `const delta = saved.viewportY - termData.terminal.buffer.active.viewportY; if (delta !== 0) termData.terminal.scrollLines(delta);`

In `closeTerminal(id)` (line ~1258), add cleanup near the existing `.delete(id)` calls (around line ~1283):
- `savedScrollPositions.delete(id);`
- Do NOT delete from `lastActivePerProject` — the guard in filterByProject handles stale IDs via `getTerminal(savedId)` returning null.
  </action>
  <verify>
    <automated>cd C:/Users/uhgde/source/repos/claude-terminal && node -e "const src = require('fs').readFileSync('src/renderer/ui/components/TerminalManager.js','utf8'); const checks = ['lastActivePerProject', 'savedScrollPositions', 'lastActivePerProject.set', 'lastActivePerProject.get', 'savedScrollPositions.set', 'savedScrollPositions.get', 'savedScrollPositions.delete', 'viewportY', 'scrollTop', 'requestAnimationFrame']; const missing = checks.filter(c => !src.includes(c)); if (missing.length) { console.error('MISSING:', missing); process.exit(1); } console.log('All patterns found');"</automated>
  </verify>
  <done>setActiveTerminal captures scroll on leave, restores scroll on arrive, and records last-active per project. closeTerminal cleans up scroll data.</done>
</task>

<task type="auto">
  <name>Task 2: Use in-memory Map as primary tab restore source in filterByProject</name>
  <files>src/renderer/ui/components/TerminalManager.js</files>
  <action>
In `filterByProject()` (line ~2206), replace the tab restoration logic inside the `else` block (lines 2206-2237). The current code tries disk-based `activeTabIndex` as the only fallback when the active tab is not visible.

Replace the restoration block with an in-memory Map lookup FIRST, keeping disk-based restore as secondary fallback:

```javascript
} else {
    emptyState.style.display = 'none';
    const activeTab = document.querySelector(`.terminal-tab[data-id="${getActiveTerminal()}"]`);
    if (!activeTab || activeTab.style.display === 'none') {
      let targetId = firstVisibleId;

      // Primary: in-memory per-project last-active tab
      const project = projects[projectIndex];
      if (project) {
        const savedId = lastActivePerProject.get(project.id);
        if (savedId && getTerminal(savedId)) {
          const savedTab = tabsById.get(String(savedId));
          if (savedTab && savedTab.style.display !== 'none') {
            targetId = savedId;
          }
        }

        // Secondary fallback: disk-based activeTabIndex (app restart path)
        if (targetId === firstVisibleId) {
          try {
            const { loadSessionData } = require('../../services/TerminalSessionService');
            const sessionData = loadSessionData();
            const savedIdx = sessionData?.projects?.[project.id]?.activeTabIndex;
            if (typeof savedIdx === 'number') {
              const visibleIds = [];
              const terminals = terminalsState.get().terminals;
              terminals.forEach((td, id) => {
                const tab = tabsById.get(String(id));
                if (tab && tab.style.display !== 'none') {
                  visibleIds.push(id);
                }
              });
              if (savedIdx < visibleIds.length) {
                targetId = visibleIds[savedIdx];
              }
            }
          } catch (e) { /* session data unavailable, use firstVisibleId */ }
        }
      }

      if (targetId) setActiveTerminal(targetId);
    }
  }
```

Key changes from the existing code:
1. Added in-memory `lastActivePerProject.get(project.id)` lookup before disk fallback
2. Use `tabsById` Map (already indexed earlier in the function at line ~2144) instead of `document.querySelector` for O(1) lookup in the disk fallback path too
3. Kept existing disk-based `activeTabIndex` as secondary fallback — still needed for the first project switch after app restart before Phase 04/06's restore logic kicks in
  </action>
  <verify>
    <automated>cd C:/Users/uhgde/source/repos/claude-terminal && npm run build:renderer 2>&1 | tail -5 && npm test 2>&1 | tail -5</automated>
  </verify>
  <done>filterByProject uses in-memory Map as primary restore source, with disk-based activeTabIndex as secondary fallback. Build and tests pass.</done>
</task>

</tasks>

<verification>
1. `npm run build:renderer` succeeds without errors
2. `npm test` passes all existing tests
3. Grep confirms both Maps declared and used: `lastActivePerProject` (set in setActiveTerminal, get in filterByProject), `savedScrollPositions` (set/get in setActiveTerminal, delete in closeTerminal)
4. No new files created — single-file fix in TerminalManager.js
</verification>

<success_criteria>
- Switching between projects restores the last-active tab (not always first tab)
- Scroll position is restored for both terminal (xterm viewportY) and chat (DOM scrollTop) tabs
- Closed tabs are handled gracefully (fallback to first visible tab)
- No new dependencies, no disk I/O added
- Build and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-bugfix-swap-projects-selected-tab/20-01-SUMMARY.md`
</output>
