# Phase 2.1: Fix PR #13 Review Issues for Terminal Keyboard Shortcuts - Research

**Researched:** 2026-02-26
**Domain:** Electron main-process input interception, flat settings pattern, git rebase workflow
**Confidence:** HIGH — all findings sourced directly from the existing codebase (git diff, branch inspection)

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Ctrl+Left/Right interception strategy (Issue #1 — BLOCKER)**
- Restore Ctrl+Left/Right in MainWindow.js `before-input-event` handler
- When word-jump setting is **enabled**: only call `event.preventDefault()` to block Windows Snap — do NOT send IPC, let the event propagate naturally to renderer where xterm handles word-jump
- When word-jump setting is **disabled**: call `event.preventDefault()` AND send `ctrl-arrow` left/right IPC to renderer for old tab-switching behavior (reuse existing IPC channel)
- Add `setCtrlArrowWordJumpEnabled` IPC handler in MainWindow.js — same pattern as existing `setCtrlTabEnabled`
- Sync word-jump setting to main process on startup and on settings change — mirrors ctrlTab sync pattern
- Relabel the setting in Shortcuts UI: make it clear this is "Word jump (Ctrl+←/→) — like Windows Terminal" so users understand enabling it replaces old tab-switching

**Rebase approach (Issue #2)**
- Rebase `feat/terminal-keyboard-shortcuts` on top of main (which includes PR #12 changes)
- Claude decides whether to use fork's main or upstream main based on what's actually on each branch
- Resolve merge conflicts in TerminalManager.js during rebase
- Remove duplicated `findClaudeTerminalForProject` helper — use main's version from merged PR #8
- Keep as single squashed commit after all fixes applied

**Settings flattening convention (Issue #3)**
- Flatten nested `terminalShortcuts` object to flat keys matching existing settings pattern
- Naming convention: `shortcut` prefix + key name + `Enabled`/`Key` suffix (camelCase)
- Full flat key list:
  - `shortcutCtrlCEnabled` (default: true)
  - `shortcutCtrlCKey` (default: 'C')
  - `shortcutCtrlVEnabled` (default: true)
  - `shortcutCtrlVKey` (default: 'V')
  - `shortcutCtrlArrowEnabled` (default: true)
  - `shortcutCtrlTabEnabled` (default: true)
  - `shortcutRightClickPasteEnabled` (default: true)
  - `shortcutRightClickCopyPasteEnabled` (default: false)
- Remove deep-merge logic from `loadSettings()` entirely — flat keys use standard `{ ...defaultSettings, ...saved }` spread like all other settings
- No migration shim for old nested format — clean break
- Update all consumers: TerminalManager.js key handler, ShortcutsManager.js toggle UI, MainWindow.js IPC sync

### Claude's Discretion
- Choosing fork main vs upstream main for rebase base (inspect actual branch state)
- Exact conflict resolution strategy during rebase
- Whether `event.preventDefault()` alone is sufficient to block Windows Snap while allowing natural propagation, or if a different approach is needed
- Keeping `terminalContextMenu` setting or folding it into the flat shortcut keys

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

---

## Summary

Phase 2.1 is a targeted PR cleanup phase that addresses three reviewer comments from upstream maintainer Sterll on PR #13. The branch `feat/terminal-keyboard-shortcuts` already exists on both the fork (`origin/feat/terminal-keyboard-shortcuts`) and is current as of commit `40403d4b`. The three fixes are: (1) restore Ctrl+Left/Right interception in main process to prevent Windows Snap while routing to word-jump instead of tab switching, (2) rebase the branch on top of the fork's `main` (which already contains PR #12 via commit `45558529`) and remove a duplicated helper, (3) flatten the nested `terminalShortcuts` settings object to the flat key pattern used everywhere else in the codebase.

The ctrlTab pattern already implemented on the branch is the proven template for Issue #1. The branch has `ctrlTabEnabled` flag + `setCtrlTabEnabled` export + `terminal:setCtrlTabEnabled` IPC handler + startup sync in `renderer.js` + settings subscribe for live sync. Issue #1 requires applying the exact same pattern for `ctrlArrowWordJumpEnabled`. Issue #3 (flattening) requires touching four files: `settings.state.js`, `TerminalManager.js`, `ShortcutsManager.js`, and `renderer.js`. No new dependencies are needed.

**Primary recommendation:** Implement the three fixes sequentially — Issue #3 (flattening) first because it changes the data model that Issues #1 and the IPC sync both read; then Issue #1 (main process intercept); then rebase last to minimize conflict surface.

---

## Standard Stack

### Core (no new dependencies — all existing)

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Electron `ipcMain` / `ipcRenderer` | ^28.0.0 (existing) | Main↔renderer communication | Already used for `setCtrlTabEnabled` pattern |
| `before-input-event` API | Electron built-in | Block OS-level keyboard events before renderer sees them | Established pattern in `MainWindow.js` line 43 |
| xterm.js `attachCustomKeyEventHandler` | ^6.0.0 (existing) | Terminal-specific key routing | Already used for all terminal shortcuts |

**Installation:** None required — no new packages.

---

## Architecture Patterns

### Pattern 1: ctrlTabEnabled flag in MainWindow.js (THE TEMPLATE)

This is the exact pattern to replicate for `ctrlArrowWordJumpEnabled`. From the branch's `MainWindow.js`:

```js
// Module-level flag (default: true)
let ctrlTabEnabled = true;

// In before-input-event handler:
if (input.key === 'Tab' && ctrlTabEnabled) {
  event.preventDefault();
  mainWindow.webContents.send('ctrl-tab', input.shift ? 'prev' : 'next');
  return;
}

// Export the setter
function setCtrlTabEnabled(enabled) {
  ctrlTabEnabled = !!enabled;
}

module.exports = { ..., setCtrlTabEnabled };
```

For Issue #1, the `ctrlArrowWordJumpEnabled` flag requires a different two-mode behavior:

```js
let ctrlArrowWordJumpEnabled = true; // new flag

// In before-input-event handler, within modKey && !input.alt && input.type === 'keyDown':
if (!input.shift) {
  const lrDir = { Left: 'left', ArrowLeft: 'left', Right: 'right', ArrowRight: 'right' }[input.key];
  if (lrDir) {
    event.preventDefault(); // ALWAYS prevent Windows Snap for Left/Right
    if (!ctrlArrowWordJumpEnabled) {
      // word-jump disabled → old tab-switch behavior
      mainWindow.webContents.send('ctrl-arrow', lrDir);
    }
    // word-jump enabled → preventDefault alone is sufficient; renderer xterm handles word-jump naturally
    return;
  }
}
```

Key insight from CONTEXT.md: when word-jump is **enabled**, `event.preventDefault()` alone blocks Windows Snap and the key propagates naturally to the renderer/xterm. The xterm handler in `TerminalManager.js` already sends the escape sequences `\x1b[1;5D` / `\x1b[1;5C` on Ctrl+Left/Right when `shortcutCtrlArrowEnabled` (flat key) is true. No additional IPC needed.

### Pattern 2: IPC chain for new main-process flag (mirroring setCtrlTabEnabled)

**File chain (four files):**

1. `src/main/windows/MainWindow.js` — add `ctrlArrowWordJumpEnabled` flag + `setCtrlArrowWordJumpEnabled(enabled)` function + export it
2. `src/main/ipc/terminal.ipc.js` — add `ipcMain.handle('terminal:setCtrlArrowWordJumpEnabled', ...)` handler, lazy-require MainWindow (Phase 04 circular-dep pattern)
3. `src/main/preload.js` — add `setCtrlArrowWordJumpEnabled: (enabled) => ipcRenderer.invoke('terminal:setCtrlArrowWordJumpEnabled', enabled)` in `terminal` namespace
4. `renderer.js` — startup sync + settingsState.subscribe for live sync (same structure as ctrlTab sync block)

**Startup sync pattern from renderer.js (branch):**
```js
const _startupTs = getSetting('terminalShortcuts') || {};
api.terminal.setCtrlTabEnabled(_startupTs.ctrlTab?.enabled !== false);

let _prevCtrlTabEnabled = _startupTs.ctrlTab?.enabled !== false;
settingsState.subscribe(() => {
  const _current = getSetting('terminalShortcuts')?.ctrlTab?.enabled !== false;
  if (_current !== _prevCtrlTabEnabled) {
    _prevCtrlTabEnabled = _current;
    api.terminal.setCtrlTabEnabled(_current);
  }
});
```

After flattening (Issue #3), this becomes:
```js
api.terminal.setCtrlTabEnabled(getSetting('shortcutCtrlTabEnabled') !== false);
api.terminal.setCtrlArrowWordJumpEnabled(getSetting('shortcutCtrlArrowEnabled') !== false);
```

### Pattern 3: Flat settings keys (Issue #3 — the existing pattern)

Current `defaultSettings` in `settings.state.js` uses flat keys. The branch's `terminalShortcuts` nested object is the outlier. The fix:

```js
// REMOVE from defaultSettings (branch):
terminalShortcuts: {
  ctrlC:              { enabled: true  },
  ctrlV:              { enabled: true  },
  ctrlArrow:          { enabled: true  },
  ctrlTab:            { enabled: true  },
  rightClickPaste:    { enabled: true  },
  rightClickCopyPaste:{ enabled: false }
}

// ADD flat keys to defaultSettings:
shortcutCtrlCEnabled: true,
shortcutCtrlCKey: 'C',
shortcutCtrlVEnabled: true,
shortcutCtrlVKey: 'V',
shortcutCtrlArrowEnabled: true,
shortcutCtrlTabEnabled: true,
shortcutRightClickPasteEnabled: true,
shortcutRightClickCopyPasteEnabled: false,
```

The `loadSettings()` function's deep-merge block is removed. The existing `{ ...defaultSettings, ...saved }` spread works correctly for flat keys.

The `terminalContextMenu` key (also added by the branch) is a separate flat key that does NOT follow the `shortcut` prefix. Claude's discretion: keep it as-is (it's already flat and correctly named).

### Pattern 4: Consumer update locations for flat keys

Four consumer locations to update:

**`settings.state.js`:**
- Remove `terminalShortcuts` from `defaultSettings`
- Add 8 flat `shortcutXxx` keys
- Remove deep-merge block from `loadSettings()`

**`TerminalManager.js`:** All reads of `getSetting('terminalShortcuts')?.xxx?.enabled` become `getSetting('shortcutXxxEnabled')`. All reads of `ts.xxx?.key` become `getSetting('shortcutXxxKey')`. Specific sites:
- `createTerminalKeyHandler()` — reads `ctrlC.enabled`, `ctrlC.key`, `ctrlV.enabled`, `ctrlV.key`, `ctrlArrow.enabled`
- `setupRightClickHandler()` — reads `rightClickCopyPaste.enabled`, `rightClickPaste.enabled`

**`ShortcutsManager.js`:** `TERMINAL_SHORTCUTS` entries read from `terminalShortcuts[id]?.enabled` and `terminalShortcuts[id]?.key`. These become direct `getSetting('shortcutXxxEnabled')` calls. The `getTerminalShortcutKey(id)` helper maps id → flat key name. Toggle `onchange` writes `setProp('shortcutXxxEnabled', enabled)` instead of deep-merging into `terminalShortcuts`.

**`renderer.js`:** The startup sync block reads `getSetting('shortcutCtrlTabEnabled') !== false` and `getSetting('shortcutCtrlArrowEnabled') !== false`.

### Pattern 5: Rebase workflow (Issue #2)

The fork's `main` branch already contains PR #12 (commit `45558529 fix(chat): preserve model, effort and permissions on session fork`). The keyboard shortcuts branch diverged from an earlier main. Rebase target: fork's `main` (not upstream/main — upstream is ahead with unrelated features like cloud relay, snap packaging).

The `findClaudeTerminalForProject` helper duplicated from PR #8 — the version on `main` (merged via PR #8) is the authoritative one. During rebase conflict resolution, keep `main`'s version of `findClaudeTerminalForProject` and discard the one added on the keyboard shortcuts branch.

After all code fixes are applied on the rebased branch, squash to a single commit per the squash PR playbook.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Blocking Windows Snap | Custom OS hook | Electron `before-input-event` with `event.preventDefault()` | Already proven to work for Ctrl+Tab; same mechanism for Left/Right |
| Flat settings migration | Migration shim for nested→flat | Clean break (no migration) | User decision: no migration shim; new install and existing installs both get safe defaults via `!== false` guard |
| Deep merge | Custom recursive merge | Remove it entirely | The whole point of Issue #3 is to eliminate this complexity |

**Key insight:** The `before-input-event` handler's `event.preventDefault()` call is idempotent — calling it when word-jump is enabled is sufficient to block Windows Snap without any additional routing. The event still reaches the renderer's xterm handler (xterm uses DOM events, not IPC), so word-jump escape sequences fire normally.

---

## Common Pitfalls

### Pitfall 1: `event.preventDefault()` vs event propagation to xterm
**What goes wrong:** Assuming `event.preventDefault()` in `before-input-event` blocks the event from reaching the renderer entirely.
**Why it happens:** Confusing Electron's `before-input-event` (which targets `webContents`) with DOM `preventDefault()` (which only stops browser default behavior).
**How to avoid:** `event.preventDefault()` in `before-input-event` prevents the OS/Chromium default (Windows Snap, browser shortcut), but the keystroke still propagates to the renderer's DOM. xterm's `attachCustomKeyEventHandler` fires regardless. So preventing Windows Snap AND allowing xterm word-jump to work simultaneously is correct behavior — no special handling needed.
**Confidence:** HIGH — confirmed by the branch behavior where Ctrl+Tab is intercepted via `before-input-event` yet xterm still receives keyboard events.

### Pitfall 2: Flat key naming collision with `shortcut` (app-level shortcuts namespace)
**What goes wrong:** The existing `shortcuts` key in settings stores custom app-level shortcut bindings (openSettings, closeTerminal, etc.). The new flat `shortcutXxx` keys sit at the same level.
**Why it happens:** The `shortcuts` object (plural, no prefix) and `shortcutCtrlCEnabled` (singular prefix) could confuse future developers.
**How to avoid:** The naming convention is clear from CONTEXT.md: `shortcut` prefix + camelCase key name + `Enabled`/`Key` suffix. The existing `shortcuts` object remains untouched.

### Pitfall 3: Lazy require pattern for IPC handler
**What goes wrong:** Directly requiring `MainWindow.js` at the top of `terminal.ipc.js` causes circular dependency errors.
**Why it happens:** Module load order in Node.js with circular requires.
**How to avoid:** Follow the Phase 04 pattern: use lazy require inside the ipcMain handler function body.
```js
ipcMain.handle('terminal:setCtrlArrowWordJumpEnabled', (event, enabled) => {
  const { setCtrlArrowWordJumpEnabled } = require('../windows/MainWindow');
  setCtrlArrowWordJumpEnabled(enabled);
});
```
The branch already does this correctly for `setCtrlTabEnabled`.

### Pitfall 4: ShortcutsManager reading from wrong location after flattening
**What goes wrong:** `getTerminalShortcutKey(id)` and toggle handlers still reference `ctx.settingsState.get().terminalShortcuts` after it's removed.
**Why it happens:** Multiple read/write sites scattered across ShortcutsManager.js.
**How to avoid:** Replace with direct `getSetting('shortcutXxxEnabled')` and `getSetting('shortcutXxxKey')` calls. The `TERMINAL_SHORTCUTS` constant stays as a UI definition (labels, defaults, rebindable flags) — only the persistence layer changes.

### Pitfall 5: Rebase conflict in TerminalManager.js
**What goes wrong:** The rebase produces a complex 3-way merge in TerminalManager.js where both branches have significant changes.
**Why it happens:** PR #12 also touched TerminalManager.js (chat fork, session restore).
**How to avoid:** During rebase conflict resolution, accept the keyboard shortcuts branch changes for all shortcut-related code blocks; accept main's changes for session/chat code. The `findClaudeTerminalForProject` function: keep main's version (from PR #8) and discard the keyboard branch duplicate.

### Pitfall 6: `shortcutCtrlArrowEnabled` label in ShortcutsManager UI
**What goes wrong:** The label "Word jump (Ctrl+←/→)" doesn't make it clear the feature replaces old tab-switching behavior.
**Why it happens:** Original label `shortcuts.termCtrlArrow` was brief.
**How to avoid:** Update the i18n key `shortcuts.termCtrlArrow` to "Word jump (Ctrl+←/→) — replaces tab switching" (EN) per CONTEXT.md decision to "make it clear this is like Windows Terminal."

---

## Code Examples

### Issue #1: Two-mode before-input-event handler for Ctrl+Left/Right

```js
// src/main/windows/MainWindow.js

let ctrlTabEnabled = true;
let ctrlArrowWordJumpEnabled = true; // NEW

// In before-input-event:
const modKey = process.platform === 'darwin' ? input.meta : input.control;
if (modKey && !input.alt && input.type === 'keyDown') {
  // Ctrl+Tab / Ctrl+Shift+Tab
  if (input.key === 'Tab' && ctrlTabEnabled) {
    event.preventDefault();
    mainWindow.webContents.send('ctrl-tab', input.shift ? 'prev' : 'next');
    return;
  }

  if (!input.shift) {
    // Ctrl+Left/Right: always preventDefault for Windows Snap bypass
    const lrDir = { Left: 'left', ArrowLeft: 'left', Right: 'right', ArrowRight: 'right' }[input.key];
    if (lrDir) {
      event.preventDefault();
      if (!ctrlArrowWordJumpEnabled) {
        // Word-jump disabled → send IPC for old tab-switch behavior
        mainWindow.webContents.send('ctrl-arrow', lrDir);
      }
      // Word-jump enabled → preventDefault alone; xterm handles naturally
      return;
    }

    // Ctrl+Up/Down: project switching (unchanged)
    const udDir = { Up: 'up', ArrowUp: 'up', Down: 'down', ArrowDown: 'down' }[input.key];
    if (udDir) {
      event.preventDefault();
      mainWindow.webContents.send('ctrl-arrow', udDir);
    }
  }
}

function setCtrlArrowWordJumpEnabled(enabled) {
  ctrlArrowWordJumpEnabled = !!enabled;
}

module.exports = { ..., setCtrlTabEnabled, setCtrlArrowWordJumpEnabled };
```

### Issue #3: Flat settings keys

```js
// settings.state.js defaultSettings additions
shortcutCtrlCEnabled: true,
shortcutCtrlCKey: 'C',
shortcutCtrlVEnabled: true,
shortcutCtrlVKey: 'V',
shortcutCtrlArrowEnabled: true,
shortcutCtrlTabEnabled: true,
shortcutRightClickPasteEnabled: true,
shortcutRightClickCopyPasteEnabled: false,
// terminalContextMenu stays as-is (already flat)

// loadSettings(): remove the deep-merge block, keep standard spread:
settingsState.set({ ...defaultSettings, ...saved });
```

### Consumer reads in TerminalManager.js (before → after)

```js
// BEFORE (branch):
const ts = getSetting('terminalShortcuts') || {};
if (ts.ctrlArrow?.enabled === false) return true;
if (ts.rightClickCopyPaste?.enabled) { ... }
if (ts.rightClickPaste?.enabled !== false && !getSetting('terminalContextMenu')) { ... }
const ctrlCCustomKey = ts.ctrlC?.key;

// AFTER (flat):
if (getSetting('shortcutCtrlArrowEnabled') === false) return true;
if (getSetting('shortcutRightClickCopyPasteEnabled')) { ... }
if (getSetting('shortcutRightClickPasteEnabled') !== false && !getSetting('terminalContextMenu')) { ... }
const ctrlCCustomKey = getSetting('shortcutCtrlCKey');
```

### ShortcutsManager toggle handler (before → after)

```js
// BEFORE (branch):
checkbox.onchange = (e) => {
  const id = e.target.dataset.id;
  const enabled = e.target.checked;
  const ts = ctx.settingsState.get().terminalShortcuts || {};
  const updated = { ...ts, [id]: { ...(ts[id] || {}), enabled } };
  ctx.settingsState.setProp('terminalShortcuts', updated);
  ctx.saveSettings();
};

// AFTER (flat) — need a mapping from id → flat key:
const ID_TO_ENABLED_KEY = {
  ctrlC: 'shortcutCtrlCEnabled',
  ctrlV: 'shortcutCtrlVEnabled',
  ctrlArrow: 'shortcutCtrlArrowEnabled',
  ctrlTab: 'shortcutCtrlTabEnabled',
  rightClickPaste: 'shortcutRightClickPasteEnabled',
  rightClickCopyPaste: 'shortcutRightClickCopyPasteEnabled',
};

checkbox.onchange = (e) => {
  const id = e.target.dataset.id;
  const flatKey = ID_TO_ENABLED_KEY[id];
  if (flatKey) {
    ctx.settingsState.setProp(flatKey, e.target.checked);
    ctx.saveSettings();
  }
};
```

### Startup sync in renderer.js (after flattening + new ctrlArrow sync)

```js
// Sync Ctrl+Tab and Ctrl+Arrow word-jump enabled states to main process on startup
api.terminal.setCtrlTabEnabled(getSetting('shortcutCtrlTabEnabled') !== false);
api.terminal.setCtrlArrowWordJumpEnabled(getSetting('shortcutCtrlArrowEnabled') !== false);

let _prevCtrlTab = getSetting('shortcutCtrlTabEnabled') !== false;
let _prevCtrlArrow = getSetting('shortcutCtrlArrowEnabled') !== false;
settingsState.subscribe(() => {
  const _tab = getSetting('shortcutCtrlTabEnabled') !== false;
  const _arrow = getSetting('shortcutCtrlArrowEnabled') !== false;
  if (_tab !== _prevCtrlTab) { _prevCtrlTab = _tab; api.terminal.setCtrlTabEnabled(_tab); }
  if (_arrow !== _prevCtrlArrow) { _prevCtrlArrow = _arrow; api.terminal.setCtrlArrowWordJumpEnabled(_arrow); }
});
```

---

## Files Modified (complete list)

| File | Issue | Change Type |
|------|-------|-------------|
| `src/main/windows/MainWindow.js` | #1 | Add `ctrlArrowWordJumpEnabled` flag, restore Left/Right in handler, add `setCtrlArrowWordJumpEnabled` export |
| `src/main/ipc/terminal.ipc.js` | #1 | Add `terminal:setCtrlArrowWordJumpEnabled` IPC handler (lazy require) |
| `src/main/preload.js` | #1 | Add `setCtrlArrowWordJumpEnabled` in `terminal` namespace |
| `src/renderer/state/settings.state.js` | #3 | Remove `terminalShortcuts` nested object, add 8 flat `shortcutXxx` keys, remove deep-merge from `loadSettings()` |
| `src/renderer/ui/components/TerminalManager.js` | #3 | Update all `getSetting('terminalShortcuts')?.xxx` reads to flat key reads |
| `src/renderer/ui/panels/ShortcutsManager.js` | #3 | Update `getTerminalShortcutKey()`, toggle handlers, render logic to use flat keys; update `ctrlArrow` label text |
| `renderer.js` | #1 + #3 | Replace startup sync block with flat keys + add `setCtrlArrowWordJumpEnabled` sync |
| `src/renderer/i18n/locales/en.json` | #1 | Update `shortcuts.termCtrlArrow` label to clarify word-jump replaces tab switching |
| `src/renderer/i18n/locales/fr.json` | #1 | Same label update in French |
| `feat/terminal-keyboard-shortcuts` (git) | #2 | Rebase on fork's `main`, resolve TerminalManager.js conflicts, remove duplicated `findClaudeTerminalForProject` |

**Files NOT touched:** `src/main/services/TerminalService.js`, `index.html`, CSS files, project-types.

---

## Branch State Analysis (for rebase decision)

**Fork's `main` HEAD:** `6e89c9fc docs(state): record phase 2.1 context session`
**Fork's `main` includes PR #12:** Yes — commit `45558529 fix(chat): preserve model, effort and permissions on session fork` is present.
**Upstream's `main` HEAD:** `21b112c1 fix(webapp): reposition all pin types on scroll` — ahead with unrelated features (cloud relay, snap, etc.).
**Rebase target decision (Claude's discretion):** Use **fork's `main`** (not upstream/main). Upstream has additional unrelated features that are not part of this PR's scope and would pollute the commit history.

**`findClaudeTerminalForProject` conflict:** This helper appears both on the keyboard branch (added in its commit `40403d4b`) and was first introduced by PR #8. PR #8 is merged into fork's `main`. During rebase conflict resolution, keep main's version.

---

## Open Questions

1. **Does `event.preventDefault()` alone actually block Windows Snap for Ctrl+Left/Right?**
   - What we know: The original `main` code called `event.preventDefault()` + sent IPC for all four Ctrl+Arrow directions. The reviewer said this was "specifically to prevent Windows from snapping the window."
   - What's unclear: Whether `event.preventDefault()` in `before-input-event` is sufficient to block Windows Snap, or if Windows intercepts at a lower level than Chromium.
   - Recommendation (Claude's discretion from CONTEXT.md): Implement as designed (preventDefault alone). If Windows Snap still fires, the fallback is to also call `mainWindow.webContents.send('ctrl-arrow', lrDir)` even when word-jump is enabled — the renderer can then ignore it if word-jump mode is active. Test on Windows after implementation.

2. **`terminalContextMenu` flat key — keep or rename?**
   - What we know: The branch added `terminalContextMenu: true` as a flat key. CONTEXT.md says Claude's discretion on "keeping `terminalContextMenu` setting or folding it into the flat shortcut keys."
   - Recommendation: Keep `terminalContextMenu` as-is. It controls a distinct behavior (show menu vs instant paste) that is logically separate from the shortcut enable/disable keys. Renaming it to `shortcutContextMenuEnabled` would be confusing since it's not a keyboard shortcut per se.

---

## Sources

### Primary (HIGH confidence)
- Direct inspection of `feat/terminal-keyboard-shortcuts` branch (commit `40403d4b`) via `git diff main feat/terminal-keyboard-shortcuts`
- PR #13 review comment from Sterll (retrieved via `gh pr view 13 --repo Sterll/claude-terminal --comments`)
- `src/main/windows/MainWindow.js` — existing ctrlTabEnabled pattern
- `src/main/ipc/terminal.ipc.js` on branch — existing setCtrlTabEnabled IPC chain
- `src/renderer/state/settings.state.js` — existing flat settings pattern (all other keys)
- `renderer.js` branch diff — startup sync pattern for ctrlTab

### Secondary (MEDIUM confidence)
- CONTEXT.md decisions (user-locked, authoritative for this phase)
- STATE.md accumulated decisions for Phase 7-02 (ctrlTab pattern documented)

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — no new libraries, all patterns sourced from existing branch code
- Architecture: HIGH — IPC chain pattern is already working (ctrlTab); flattening is mechanical text substitution
- Pitfalls: HIGH — sourced from existing codebase patterns and Phase decisions log

**Research date:** 2026-02-26
**Valid until:** 2026-03-28 (30 days; stable codebase, no fast-moving dependencies)
