---
phase: 22-explorer-filewatcher
plan: 04
type: execute
wave: 1
depends_on: ["22-03"]
files_modified:
  - src/main/ipc/explorer.ipc.js
  - src/main/preload.js
  - src/renderer/ui/components/FileExplorer.js
  - renderer.js
autonomous: true
requirements: [EXPL-WATCH-01]
gap_closure: true
must_haves:
  truths:
    - "File watcher only watches directories currently expanded in the UI, not the entire project tree"
    - "Expanding a folder starts a shallow watcher for that directory"
    - "Collapsing a folder stops its watcher"
    - "Collapse-all and refresh buttons stop all directory watchers"
    - "Project switch stops old watchers and starts watchers for restored expanded paths"
    - "New files and deletions in watched directories still appear/disappear automatically"
  artifacts:
    - path: "src/main/ipc/explorer.ipc.js"
      provides: "Per-directory shallow watcher Map with watchDir/unwatchDir/stopAllDirWatchers"
      contains: "dirWatchers"
    - path: "src/main/preload.js"
      provides: "watchDir and unwatchDir IPC methods in explorer namespace"
      contains: "watchDir"
    - path: "src/renderer/ui/components/FileExplorer.js"
      provides: "watchDir/unwatchDir calls in toggleFolder, collapse-all, refresh, setRootPath, restoreState"
      contains: "api.explorer.watchDir"
    - path: "renderer.js"
      provides: "Shallow root-only watch on project select via watchDir"
      contains: "api.explorer.watchDir"
  key_links:
    - from: "src/renderer/ui/components/FileExplorer.js"
      to: "src/main/ipc/explorer.ipc.js"
      via: "api.explorer.watchDir/unwatchDir IPC calls"
      pattern: "api\\.explorer\\.watchDir"
    - from: "renderer.js"
      to: "src/main/ipc/explorer.ipc.js"
      via: "api.explorer.watchDir for root directory on project select"
      pattern: "api\\.explorer\\.watchDir\\(project\\.path\\)"
---

<objective>
Replace the single recursive chokidar watcher with per-directory shallow watchers that only watch directories currently expanded in the file explorer UI.

Purpose: Fix performance blocker — the current recursive watcher opens one native OS handle per non-ignored directory in the project tree (thousands for monorepos), regardless of UI visibility. Per-directory depth:0 watchers reduce handle count from thousands to typically 1-50.

Output: Refactored explorer.ipc.js with Map-based per-directory watchers, updated preload bridge, FileExplorer.js wired to watchDir/unwatchDir on expand/collapse, renderer.js using shallow root-only watch.
</objective>

<execution_context>
@C:/Users/uhgde/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/uhgde/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-explorer-filewatcher/22-03-SUMMARY.md
@.planning/debug/watcher-performance-recursive.md

<interfaces>
<!-- Current explorer.ipc.js exports (will be refactored): -->
```js
// src/main/ipc/explorer.ipc.js — current module.exports
module.exports = { registerExplorerHandlers, stopWatch };
```

<!-- Current preload explorer namespace (lines 215-228, DUPLICATED — second copy is dead code): -->
```js
explorer: {
  startWatch: (projectPath) => ipcRenderer.send('explorer:startWatch', projectPath),
  stopWatch: () => ipcRenderer.send('explorer:stopWatch'),
  onChanges: createListener('explorer:changes'),
  onWatchLimitWarning: createListener('explorer:watchLimitWarning')
},
```

<!-- FileExplorer.js key references: -->
```js
const api = window.electron_api;  // line 7
// toggleFolder at line 1358 — expand/collapse logic
// btnCollapse.onclick at line 1300 — collapse-all
// btnRefresh.onclick at line 1310 — refresh
// setRootPath at line 200 — project switch with savedExpandedPaths restore
// restoreState at line 130 — restore from disk-saved state (expandedPaths array)
// applyWatcherChanges at line 477 — NO changes needed (already per-directory semantics)
```

<!-- renderer.js FILE WATCHER section (lines 1568-1596): -->
```js
api.explorer.onChanges((changes) => {
  FileExplorer.applyWatcherChanges(changes).catch(() => {});
});
api.explorer.onWatchLimitWarning((totalPaths) => {
  showToast({ type: 'warning', title: t('fileExplorer.title'), message: t('fileExplorer.watchLimitWarning', { count: totalPaths }) });
});
// Project subscriber at line 1591:
api.explorer.startWatch(project.path);  // THIS becomes watchDir
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor explorer.ipc.js to per-directory shallow watchers and update preload bridge</name>
  <files>src/main/ipc/explorer.ipc.js, src/main/preload.js</files>
  <action>
**explorer.ipc.js — full refactor of watcher model:**

1. Replace `activeWatcher` (single FSWatcher) with `const dirWatchers = new Map()` where keys are dirPath strings and values are `{ watcher, watchId }` objects.

2. Remove the `startWatch(projectPath)` function entirely.

3. Add `watchDir(dirPath)` function:
   - If `dirWatchers.has(dirPath)` return early (already watching).
   - Increment `watchId` and capture as `myWatchId`.
   - Create chokidar watcher with these exact options (preserving Plan 03 error handling):
     ```js
     chokidar.watch(dirPath, {
       ignored: makeIgnoredFn(),
       persistent: true,
       ignoreInitial: true,
       ignorePermissionErrors: true,
       depth: 0,
       awaitWriteFinish: { stabilityThreshold: 200, pollInterval: 100 }
     })
     ```
   - Wire `.on('add', ...)`, `.on('addDir', ...)`, `.on('unlink', ...)`, `.on('unlinkDir', ...)` to the EXISTING `pushChange` function — but pushChange must now accept 4 args: `(type, filePath, isDirectory, myWatchId)`. Update the `pushChange` function signature to accept a watchId param and check that the entry for the source dir still exists (i.e. `dirWatchers` has an entry with matching watchId). The simplest approach: just check `myWatchId !== watchId` is NOT sufficient anymore since watchId is per-entry. Instead, for the stale check in pushChange: look up `dirWatchers.get(path.dirname(filePath))` and verify its `.watchId === myWatchId`. OR simpler: don't use the global watchId for per-dir watchers at all — just check `dirWatchers.has(dirPath)` where dirPath is the watched directory. The SIMPLEST correct approach: capture `dirPath` in the closure, and in pushChange check `const entry = dirWatchers.get(dirPath); if (!entry || entry.watchId !== myWatchId) return;`.
   - Wire `.on('error', () => {})` (silent, same as Plan 03).
   - Store `dirWatchers.set(dirPath, { watcher, watchId: myWatchId })`.

4. Add `unwatchDir(dirPath)` function:
   - Get entry from `dirWatchers.get(dirPath)`. If not found, return.
   - Call `entry.watcher.close()`.
   - Call `dirWatchers.delete(dirPath)`.

5. Add `stopAllDirWatchers()` function:
   - Iterate `dirWatchers.values()` and call `.watcher.close()` on each.
   - Call `dirWatchers.clear()`.
   - Clear `pendingChanges = []`.
   - If `debounceTimer !== null`, `clearTimeout(debounceTimer); debounceTimer = null;`.

6. Update `stopWatch()` to call `stopAllDirWatchers()` internally (backwards compat for the existing `explorer:stopWatch` IPC channel).

7. Update `pushChange` function: It currently takes `(type, filePath, isDirectory)`. Change to `(type, filePath, isDirectory, myWatchId, watchedDir)`. The stale check becomes: `const entry = dirWatchers.get(watchedDir); if (!entry || entry.watchId !== myWatchId) return;`. The rest (pendingChanges.push, debounce timer) stays identical — all watchers feed through the same debounced `sendBatchedChanges` / `flushChanges` mechanism.

8. Update `flushChanges`: Remove the `myWatchId !== watchId` global check at the top. Instead, just check `pendingChanges.length === 0`. The stale filtering is now done per-event in `pushChange`. Keep the `mainWindow && !mainWindow.isDestroyed()` guard.

9. Remove the `'ready'` event handler and SOFT_LIMIT check from the old single watcher (no longer applicable with per-dir watchers — each watcher watches only one directory's direct children).

10. Update IPC registration in `registerExplorerHandlers`:
    - Add: `ipcMain.on('explorer:watchDir', (event, dirPath) => { if (!dirPath || typeof dirPath !== 'string') return; watchDir(dirPath); });`
    - Add: `ipcMain.on('explorer:unwatchDir', (event, dirPath) => { if (!dirPath || typeof dirPath !== 'string') return; unwatchDir(dirPath); });`
    - Keep: `ipcMain.on('explorer:stopWatch', () => { stopWatch(); });` (now calls stopAllDirWatchers internally).
    - Remove: `ipcMain.on('explorer:startWatch', ...)` — no longer needed.

11. Update `module.exports`: `{ registerExplorerHandlers, stopWatch }` stays the same (stopWatch still exported for app shutdown).

**preload.js — update explorer namespace:**

1. Remove the DUPLICATE `explorer` block (lines 222-228 — the second copy). Keep only one.

2. Update the single remaining `explorer` namespace to:
   ```js
   explorer: {
     startWatch: (projectPath) => ipcRenderer.send('explorer:watchDir', projectPath),
     stopWatch: () => ipcRenderer.send('explorer:stopWatch'),
     watchDir: (dirPath) => ipcRenderer.send('explorer:watchDir', dirPath),
     unwatchDir: (dirPath) => ipcRenderer.send('explorer:unwatchDir', dirPath),
     onChanges: createListener('explorer:changes'),
     onWatchLimitWarning: createListener('explorer:watchLimitWarning')
   },
   ```
   Note: `startWatch` is kept as an alias for `watchDir` for backwards compat (renderer.js project subscriber). `onWatchLimitWarning` kept even though soft-limit is removed — harmless no-op listener.
  </action>
  <verify>
    <automated>cd C:/Users/uhgde/source/repos/claude-terminal && node -e "const m = require('./src/main/ipc/explorer.ipc.js'); console.log('exports:', Object.keys(m)); console.log('OK')" && npm test && npm run build:renderer</automated>
  </verify>
  <done>
    - explorer.ipc.js uses Map-based per-directory depth:0 chokidar watchers
    - watchDir/unwatchDir/stopAllDirWatchers functions exist and are wired to IPC channels
    - Old single recursive startWatch function is removed
    - pushChange feeds all watchers through the same debounced flush mechanism
    - Plan 03 error handling preserved: persistent:true, ignorePermissionErrors:true, .on('error') silent handler
    - preload.js has single explorer namespace with watchDir, unwatchDir, startWatch (alias), stopWatch
    - Duplicate explorer key removed from preload.js
    - All tests pass, renderer builds
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire FileExplorer.js and renderer.js to use per-directory watchers</name>
  <files>src/renderer/ui/components/FileExplorer.js, renderer.js</files>
  <action>
**FileExplorer.js — add watchDir/unwatchDir calls at 5 locations:**

1. **toggleFolder (line 1358):** Add `api.explorer.watchDir(folderPath)` after the expand branch (the `else if (!entry)` block, after `getOrLoadFolder(folderPath)`). Add `api.explorer.unwatchDir(folderPath)` in the collapse branch (the `if (entry && entry.loaded)` block, before or after `expandedFolders.delete(folderPath)`). Result:
   ```js
   function toggleFolder(folderPath) {
     const entry = expandedFolders.get(folderPath);
     if (entry && entry.loaded) {
       expandedFolders.delete(folderPath);
       api.explorer.unwatchDir(folderPath);
       render();
     } else if (!entry) {
       getOrLoadFolder(folderPath);
       api.explorer.watchDir(folderPath);
       render();
     }
     _triggerSave();
   }
   ```

2. **btnCollapse.onclick (line 1300):** Before `expandedFolders.clear()`, iterate and unwatch each:
   ```js
   btnCollapse.onclick = () => {
     for (const p of expandedFolders.keys()) {
       api.explorer.unwatchDir(p);
     }
     expandedFolders.clear();
     selectedFiles.clear();
     lastSelectedFile = null;
     render();
   };
   ```

3. **btnRefresh.onclick (line 1310):** Same pattern — unwatch each before clearing:
   ```js
   btnRefresh.onclick = () => {
     for (const p of expandedFolders.keys()) {
       api.explorer.unwatchDir(p);
     }
     expandedFolders.clear();
     render();
     refreshGitStatus();
   };
   ```

4. **restoreState (lines 130-197):** After each folder is successfully loaded (in the `.then()` callbacks where `entry.loaded = true`), call `api.explorer.watchDir(folderPath)`. There are two `.then()` callbacks in restoreState — one at line 162 (new entry) and one at line 178 (existing unloaded entry). Add `api.explorer.watchDir(folderPath);` in each `.then()` after setting `loaded = true`. This ensures watchers start only for directories that actually exist and loaded successfully. Do NOT add watchDir in the `.catch()` branches.

5. **setRootPath (lines 200-256):** In the `savedExpandedPaths` restore loop (lines 233-249), after `readDirectoryAsync(p).then(children => { ... })` succeeds, add `api.explorer.watchDir(p)`. Specifically inside the `.then()` callback at line 239, after setting `entry.loaded = true; entry.loading = false;`, add `api.explorer.watchDir(p);`. Do NOT add in the `.catch()`.

**renderer.js — change startWatch to watchDir:**

At line 1591, change:
```js
api.explorer.startWatch(project.path);
```
to:
```js
api.explorer.watchDir(project.path);
```

This makes the project subscriber only watch the root directory shallowly. Deeper directories get watchers via FileExplorer.js when expanded/restored.

No other changes needed in renderer.js. The `onChanges` and `onWatchLimitWarning` listeners stay as-is. The `api.explorer.stopWatch()` call on line 1594 stays (it calls stopAllDirWatchers internally).
  </action>
  <verify>
    <automated>cd C:/Users/uhgde/source/repos/claude-terminal && node -e "const fe = require('./src/renderer/ui/components/FileExplorer.js'); console.log('exports:', Object.keys(fe)); console.log('OK')" && npm test && npm run build:renderer</automated>
  </verify>
  <done>
    - toggleFolder calls watchDir on expand, unwatchDir on collapse
    - Collapse-all and refresh buttons unwatch all directories before clearing
    - restoreState calls watchDir for each successfully loaded expanded directory
    - setRootPath's savedExpandedPaths restore calls watchDir on successful load
    - renderer.js uses watchDir(project.path) for shallow root-only watch on project select
    - stopWatch still called on project deselect (clears all watchers)
    - applyWatcherChanges unchanged (already handles per-directory semantics)
    - All tests pass, renderer builds
  </done>
</task>

</tasks>

<verification>
1. `npm test` — all existing tests pass (no regressions)
2. `npm run build:renderer` — renderer bundle builds successfully
3. Code verification:
   - `grep -n "dirWatchers" src/main/ipc/explorer.ipc.js` — Map exists
   - `grep -n "depth: 0" src/main/ipc/explorer.ipc.js` — non-recursive watcher
   - `grep -n "watchDir\|unwatchDir" src/main/preload.js` — new IPC methods
   - `grep -n "api.explorer.watchDir\|api.explorer.unwatchDir" src/renderer/ui/components/FileExplorer.js` — wired in 5+ locations
   - `grep -c "explorer:" src/main/preload.js` — should be 1 (no duplicate)
   - `grep -n "api.explorer.watchDir" renderer.js` — shallow root watch
</verification>

<success_criteria>
- File watcher uses per-directory depth:0 chokidar watchers instead of one recursive watcher
- Only expanded directories have active watchers (1-50 handles vs thousands)
- Expand/collapse/refresh/collapse-all/project-switch all manage watcher lifecycle correctly
- Plan 03 error handling preserved (persistent:true, ignorePermissionErrors:true, .catch/.on('error'))
- All existing file change detection still works (add/remove events flow through same debounced channel)
- No duplicate explorer namespace in preload.js
- All tests pass, renderer builds
</success_criteria>

<output>
After completion, create `.planning/phases/22-explorer-filewatcher/22-04-SUMMARY.md`
</output>
