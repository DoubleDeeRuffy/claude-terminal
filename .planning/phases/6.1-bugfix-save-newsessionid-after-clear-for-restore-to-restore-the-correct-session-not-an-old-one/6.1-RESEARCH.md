# Phase 6.1: Bugfix — Save NewSessionId after Clear for Restore - Research

**Researched:** 2026-02-25
**Domain:** Electron renderer — Claude event bus, session ID capture, terminal state management
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

- Update stored session ID on SESSION_START event from hooks provider
- Overwrite the old session ID completely — no history, no fallback
- Force an immediate save to disk after updating (don't rely on debounced save) — prevents data loss on crash
- Guard against null/undefined session IDs — only update if new ID is truthy (matches Phase 6 decision: guard on e.source === 'hooks')
- Each terminal tab tracks its own claudeSessionId independently (per-tab, not per-project)
- Improve on the existing findClaudeTerminalForProject heuristic (latest-terminal-ID) — instead track which Claude tab was **last active** (focused/received input) per project
- When SESSION_START fires, match it to the last-active Claude tab for that project
- This ensures /clear in one tab doesn't overwrite the session ID of another tab in the same project
- Latest always wins — each /clear overwrites the previous session ID
- On restart, resume the most recent session (the one after the last /clear)
- No special "don't resume after clear" logic — /clear starts a new session, that new session is the one to resume

### Claude's Discretion

- Exact mechanism for tracking "last active tab" (focus event, input event, or combination)
- Whether to use ClaudeEventBus events or direct terminal focus tracking
- Internal data structure for the last-active-tab lookup

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope
</user_constraints>

---

## Summary

Phase 6.1 is a surgical bugfix targeting the session ID staleness problem introduced by Phase 6. The existing `wireSessionIdCapture()` in `src/renderer/events/index.js` captures the session UUID only once on initial `SESSION_START`. When the user runs `/clear` inside a Claude terminal, Claude CLI terminates the session and starts a new one — emitting a second `SESSION_START` with a new UUID. The current code stores the UUID of the **first** session, so app restart restores the wrong (pre-clear) session.

The fix requires two changes: (1) update `wireSessionIdCapture()` to also handle subsequent `SESSION_START` events (after `/clear`), and (2) improve the `findClaudeTerminalForProject()` heuristic from "latest terminal ID" to "last-active-tab" so that a `/clear` in one tab doesn't clobber the session ID of another tab in the same project. Additionally, the debounced `saveTerminalSessions()` must be replaced with an immediate write to be crash-resilient.

**Primary recommendation:** Add a module-level `lastActiveClaudeTab: Map<projectId, terminalId>` tracking structure, updated on `setActiveTerminal()` calls in TerminalManager; then use it in `wireSessionIdCapture()` instead of `findClaudeTerminalForProject()`, while also exporting `saveTerminalSessionsImmediate` for the immediate write.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| ClaudeEventBus (internal) | current | Normalized event bus for hook events | Already used for SESSION_START in Phase 6 |
| TerminalSessionService (internal) | current | Atomic write of session data to disk | Existing persistence layer from Phase 4/6 |
| terminalsState (internal) | current | In-memory terminal state map | Single source of truth for terminal data |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `updateTerminal()` from terminals.state | current | Patch `claudeSessionId` on an existing termData | After capturing new session ID |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Module-level Map for last-active tab | Read `terminalsState.get().activeTerminal` at event time | `activeTerminal` is global across all projects — the user may have switched to a different project's tab when the hook fires; per-project Map is correct |
| Hooking xterm `onData` for last-input tracking | `setActiveTerminal()` hook | onData fires on PTY output too (not just user input); `setActiveTerminal()` fires only when the user explicitly focuses a tab |

**Installation:** No new packages required — pure code change.

---

## Architecture Patterns

### Recommended Project Structure

Only two files need modification, and one function needs to be exported from a third:

```
src/renderer/events/index.js              # wireSessionIdCapture() improved
src/renderer/ui/components/TerminalManager.js  # setActiveTerminal() updated to track last-active tab
src/renderer/services/TerminalSessionService.js  # export saveTerminalSessionsImmediate
```

### Pattern 1: Module-Level Last-Active-Tab Map

**What:** A `Map<projectId, terminalId>` maintained at the top of `events/index.js` (or a shared singleton) that records which Claude terminal was last activated per project.

**When to use:** Whenever `setActiveTerminal()` is called in TerminalManager for a Claude (non-basic, mode==='terminal') tab.

**Problem:** `events/index.js` and `TerminalManager.js` have a potential circular dependency. TerminalManager already lazy-requires from events/index.js for `updateTerminalStatus`. Going the other direction (events/index.js requiring TerminalManager) would add a circular dep.

**Recommended solution:** Place the Map and its setter in `events/index.js`, and call the setter from `TerminalManager.setActiveTerminal()` via lazy require — following the same pattern already used in Phase 6 for `wireTerminalStatusConsumer` (TerminalManager lazy-requires events/index.js via `require('../events')`).

But wait — TerminalManager does NOT currently require events/index.js. It goes the other direction: events/index.js lazy-requires TerminalManager. So the cleanest approach is:

**Option A (recommended):** Track last-active tab inside `events/index.js` using a module-level Map. Export a setter `notifyTabActivated(projectId, terminalId)`. TerminalManager calls this setter via lazy require inside `setActiveTerminal()`.

```javascript
// In events/index.js  — module-level tracking state
const lastActiveClaudeTab = new Map(); // projectId -> terminalId

function notifyTabActivated(projectId, terminalId) {
  if (projectId && terminalId !== undefined) {
    lastActiveClaudeTab.set(projectId, terminalId);
  }
}
```

```javascript
// In TerminalManager.js — inside setActiveTerminal(id)
// After setActiveTerminalState(id):
const termData = getTerminal(id);
if (termData && termData.project?.id && termData.mode === 'terminal' && !termData.isBasic) {
  try {
    const events = require('../../events'); // lazy require — avoids circular dep at load time
    events.notifyTabActivated(termData.project.id, id);
  } catch (e) { /* events not ready */ }
}
```

**Option B:** Store last-active Claude terminal ID as a property in terminalsState — but this pollutes the state module with UI-level concerns and would trigger unnecessary state notifications.

**Option C:** Scan `terminalsState` at event time for the *currently active* terminal matching `projectId`. This is simpler but unreliable — the user may have switched to a different project's tab between pressing Enter and the hook firing (hook round-trip latency: ~50-200ms).

**Verdict:** Option A is cleanest, follows established patterns (Phase 6 already uses lazy requires between these modules in this direction from TerminalManager side… actually TerminalManager does NOT call events/index.js. But Phase 6 added `wireTerminalStatusConsumer` which lazy-requires TerminalManager from events/index.js. Adding the reverse call in TerminalManager via lazy require creates a lazy cycle, not a static cycle — safe in Node.js/CommonJS since by the time `setActiveTerminal` is called, both modules are fully initialized.)

### Pattern 2: Immediate Save on Session ID Update

**What:** After `updateTerminal(terminalId, { claudeSessionId: e.data.sessionId })`, call `saveTerminalSessionsImmediate()` (bypasses 300ms debounce) instead of `saveTerminalSessions()`.

**Why:** CONTEXT.md decision: "Force an immediate save to disk after updating (don't rely on debounced save) — prevents data loss on crash."

**Current state:** `saveTerminalSessionsImmediate` is NOT exported from TerminalSessionService. It must be added to `module.exports`.

```javascript
// In TerminalSessionService.js — add to exports:
module.exports = {
  loadSessionData,
  saveTerminalSessions,
  saveTerminalSessionsImmediate,   // NEW — for crash-resilient session ID capture
  clearProjectSessions,
  updateLastOpenedProject
};
```

```javascript
// In wireSessionIdCapture() — call immediate version:
const TerminalSessionService = require('../services/TerminalSessionService');
TerminalSessionService.saveTerminalSessionsImmediate();  // was: saveTerminalSessions()
```

### Pattern 3: Overwrite on Every SESSION_START (not just first)

**What:** The existing code already overwrites — `updateTerminal(terminalId, { claudeSessionId: e.data.sessionId })` replaces the value. No special "is this a re-fire" detection needed.

**The real bug:** The existing `wireSessionIdCapture` already handles overwrite correctly. The actual problem is that `/clear` causes a new `SESSION_START` but `findClaudeTerminalForProject()` returns the **wrong terminal** when multiple tabs exist for the same project.

**Evidence:** `findClaudeTerminalForProject()` uses `latestTerminalID heuristic` — whichever terminal for the project has the highest numeric ID. This is correct when there's only one terminal, but when Tab A (ID=5) and Tab B (ID=8) exist for the same project and the user is actively using Tab A, the heuristic returns Tab B (ID=8), updating the wrong tab's `claudeSessionId`.

### Anti-Patterns to Avoid

- **Using `terminalsState.get().activeTerminal` at event time:** The hook fires asynchronously (HTTP round-trip via `HookEventServer`). The user may have clicked a different tab or switched projects in those milliseconds. The last-active-tab Map is stamped at user-action time, not at hook-fire time.
- **Storing last-active in state with state notifications:** Would trigger unnecessary re-renders. Use a plain Map.
- **Calling `saveTerminalSessions()` (debounced):** User decision mandates immediate write. 300ms debounce is too long for crash-resilience.
- **Resetting claudeSessionId on SESSION_END:** `/clear` fires `Stop` (SessionEnd) then immediately `SessionStart`. If we null out the ID on Stop, there's a brief window with no session ID. Don't reset on SessionEnd.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Circular dep avoidance | Static import | Lazy require inside function body | Established pattern in this codebase (Phases 4, 5, 6) |
| Crash-resilient write | Custom write | `saveTerminalSessionsImmediate()` | Already atomic (tmp-rename pattern) |
| Session ID validation | Regex/format check | Truthy check `if (!e.data?.sessionId) return;` | Consistent with Phase 6 decision |

**Key insight:** The entire fix is a small extension to existing infrastructure, not a new system.

---

## Common Pitfalls

### Pitfall 1: Static Circular Dependency

**What goes wrong:** If `TerminalManager.js` adds `const events = require('../../events')` at the top level, and `events/index.js` lazy-requires TerminalManager, Node.js CommonJS module loader may return a partially-initialized object.

**Why it happens:** Both modules load during app startup. Static requires at module top-level are resolved before module.exports is assigned.

**How to avoid:** Always use lazy require inside the function body of `setActiveTerminal()`. This is the same pattern used in Phase 4 (lazy require of TerminalSessionService inside `saveTerminalSessionsImmediate`) and Phase 6 (lazy require of TerminalManager inside wireTerminalStatusConsumer callbacks).

**Warning signs:** `TypeError: events.notifyTabActivated is not a function` at app startup.

### Pitfall 2: Updating Wrong Tab's sessionId on Multi-Clear

**What goes wrong:** User has Tab A (ID=5, currently active) and Tab B (ID=8, opened earlier but closed and re-opened) for the same project. User runs `/clear` in Tab A. `findClaudeTerminalForProject` returns Tab B (higher ID). Tab B's `claudeSessionId` is updated with Tab A's new session ID. On restart, Tab B resumes the wrong session.

**Why it happens:** The "latest-terminal-ID heuristic" assumes higher ID = more recently used. But terminal IDs are monotonically incremented at creation time, not at activation time.

**How to avoid:** Replace the heuristic with the `lastActiveClaudeTab` Map lookup in `wireSessionIdCapture`.

**Warning signs:** After `/clear`, reopening the app and resuming a Claude session from the wrong tab's history.

### Pitfall 3: Debounced Save Race Condition on Crash

**What goes wrong:** Session ID captured, `saveTerminalSessions()` called (debounced 300ms). App crashes within 300ms. Session ID not written to disk. On restart, old session ID is used.

**Why it happens:** The 300ms debounce is designed for frequent-save scenarios (create/close terminal). Session ID capture is a rare, high-value event where data loss has a visible impact.

**How to avoid:** Export and call `saveTerminalSessionsImmediate()` directly for session ID captures. Debounced save is still fine for routine tab operations.

### Pitfall 4: SESSION_START from Scraping Provider

**What goes wrong:** ScrapingProvider emits `SESSION_START` with `sessionId: null`. This passes the truthy check `if (!e.data?.sessionId) return;` only if the check is also there. If someone removes or bypasses the guard, null gets written to disk.

**Why it happens:** Two providers exist. ScrapingProvider (fallback) always emits sessionId: null.

**How to avoid:** Keep both guards: `if (e.source !== 'hooks') return;` AND `if (!e.data?.sessionId) return;` — same as Phase 6 original. Do not simplify to just one guard.

---

## Code Examples

Verified patterns from codebase inspection:

### Current wireSessionIdCapture (Phase 6, has the bug)

```javascript
// src/renderer/events/index.js — CURRENT (Phase 6)
function wireSessionIdCapture() {
  consumerUnsubscribers.push(
    eventBus.on(EVENT_TYPES.SESSION_START, (e) => {
      if (e.source !== 'hooks') return;
      if (!e.data?.sessionId) return;
      if (!e.projectId) return;

      // BUG: findClaudeTerminalForProject uses latest-ID heuristic
      // when multiple Claude tabs exist for same project, wrong tab may be selected
      const terminalId = findClaudeTerminalForProject(e.projectId);
      if (!terminalId) return;

      const { updateTerminal } = require('../state/terminals.state');
      updateTerminal(terminalId, { claudeSessionId: e.data.sessionId });

      // BUG: debounced save (300ms) — crash window
      const TerminalSessionService = require('../services/TerminalSessionService');
      TerminalSessionService.saveTerminalSessions();

      console.debug(`[Events] Captured session ID ${e.data.sessionId} for terminal ${terminalId}`);
    })
  );
}
```

### Fixed wireSessionIdCapture (Phase 6.1 target)

```javascript
// src/renderer/events/index.js — FIXED
// Module-level tracking (add near top alongside toolStats, sessionContext):
const lastActiveClaudeTab = new Map(); // projectId -> terminalId

function notifyTabActivated(projectId, terminalId) {
  if (projectId && terminalId !== undefined && terminalId !== null) {
    lastActiveClaudeTab.set(projectId, terminalId);
  }
}

function wireSessionIdCapture() {
  consumerUnsubscribers.push(
    eventBus.on(EVENT_TYPES.SESSION_START, (e) => {
      if (e.source !== 'hooks') return;
      if (!e.data?.sessionId) return;
      if (!e.projectId) return;

      // Use last-active-tab map instead of latest-ID heuristic
      const terminalId = lastActiveClaudeTab.get(e.projectId)
        ?? findClaudeTerminalForProject(e.projectId); // fallback if map not yet populated
      if (!terminalId) return;

      const { updateTerminal } = require('../state/terminals.state');
      updateTerminal(terminalId, { claudeSessionId: e.data.sessionId });

      // Immediate write — crash-resilient, no debounce
      const TerminalSessionService = require('../services/TerminalSessionService');
      TerminalSessionService.saveTerminalSessionsImmediate();

      console.debug(`[Events] Captured session ID ${e.data.sessionId} for terminal ${terminalId} (last-active)`);
    })
  );
}
```

### setActiveTerminal hook in TerminalManager (Phase 6.1 addition)

```javascript
// src/renderer/ui/components/TerminalManager.js — inside setActiveTerminal(id)
function setActiveTerminal(id) {
  // ... existing code: blur previous terminal ...
  setActiveTerminalState(id);
  // ... existing code: DOM class updates ...
  const termData = getTerminal(id);
  if (termData) {
    // NEW: Track last-active Claude terminal per project for session ID correlation
    if (termData.project?.id && termData.mode === 'terminal' && !termData.isBasic) {
      try {
        const events = require('../../events'); // lazy require — see Phase 4/6 pattern
        events.notifyTabActivated(termData.project.id, id);
      } catch (e) { /* events module not ready */ }
    }
    // ... existing code: focus/fit terminal ...
  }
}
```

### Export saveTerminalSessionsImmediate from TerminalSessionService

```javascript
// src/renderer/services/TerminalSessionService.js — module.exports
module.exports = {
  loadSessionData,
  saveTerminalSessions,
  saveTerminalSessionsImmediate,  // NEW export
  clearProjectSessions,
  updateLastOpenedProject
};
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| No session ID capture | wireSessionIdCapture (Phase 6) | 2026-02-25 | Session UUIDs now persisted per tab |
| Latest-ID heuristic | Last-active-tab Map (Phase 6.1) | This phase | Multi-tab /clear now updates correct tab |
| Debounced save (300ms) | Immediate save | This phase | Crash-resilient session ID persistence |

---

## Open Questions

1. **Should `notifyTabActivated` be exported from events/index.js or defined elsewhere?**
   - What we know: events/index.js exports initClaudeEvents, switchProvider, getActiveProvider, getEventBus, getDashboardStats, setNotificationFn, EVENT_TYPES
   - What's unclear: Whether adding notifyTabActivated to events/index.js exports is clean, or whether a separate thin module is better
   - Recommendation: Add to events/index.js exports — it's already the coordination layer; keeping the Map co-located with wireSessionIdCapture makes the relationship explicit

2. **What about /clear in a chat-mode tab?**
   - What we know: The session ID guard `if (td.mode !== 'terminal') continue;` in findClaudeTerminalForProject already excludes chat tabs. Phase 06-03 added chat mode support.
   - What's unclear: Whether `/clear` in a chat terminal triggers the same SessionStart hook flow
   - Recommendation: The `notifyTabActivated` filter `termData.mode === 'terminal'` should stay as-is unless Phase 06-03 confirmed chat tabs get SESSION_START hooks. If chat tabs also need updating, add `|| termData.mode === 'chat'` in both the notifyTabActivated filter and in findClaudeTerminalForProject. Verify by checking 06-03 plan.

3. **Does the fallback `?? findClaudeTerminalForProject(e.projectId)` create regression risk?**
   - What we know: The fallback fires only if `lastActiveClaudeTab` has no entry for this projectId (first SESSION_START before any tab was focused, or app restart before user tabs)
   - Recommendation: Keep the fallback — it preserves the Phase 6 behavior for single-tab projects and edge cases. The fallback is the old (buggy-only-for-multi-tab) behavior; it's correct for single-tab.

---

## Validation Architecture

> Skipped — `workflow.nyquist_validation` is not present in config.json (no validation key), and no test files exist for this subsystem.

---

## Implementation Plan Summary (for Planner)

This bugfix is a **single plan** with 3 small tasks:

**Task 1: Export saveTerminalSessionsImmediate from TerminalSessionService**
- File: `src/renderer/services/TerminalSessionService.js`
- Change: Add `saveTerminalSessionsImmediate` to `module.exports`
- Risk: Low — pure export addition, no logic change

**Task 2: Add last-active-tab tracking to events/index.js and fix wireSessionIdCapture**
- File: `src/renderer/events/index.js`
- Changes:
  - Add `const lastActiveClaudeTab = new Map()` near other module-level state
  - Add `notifyTabActivated(projectId, terminalId)` function
  - Export `notifyTabActivated` from `module.exports`
  - In `wireSessionIdCapture()`: replace `findClaudeTerminalForProject(e.projectId)` with `lastActiveClaudeTab.get(e.projectId) ?? findClaudeTerminalForProject(e.projectId)`
  - In `wireSessionIdCapture()`: replace `saveTerminalSessions()` with `saveTerminalSessionsImmediate()`
- Risk: Low — extends existing consumer, same guard logic

**Task 3: Hook setActiveTerminal in TerminalManager to update last-active-tab**
- File: `src/renderer/ui/components/TerminalManager.js`
- Change: Inside `setActiveTerminal(id)`, after `setActiveTerminalState(id)`, add lazy-require call to `events.notifyTabActivated()` for Claude terminal tabs
- Risk: Low — lazy require, try/catch, does not affect existing terminal switching behavior

---

## Sources

### Primary (HIGH confidence)
- Direct codebase inspection — `src/renderer/events/index.js` lines 160-370 (findClaudeTerminalForProject, wireSessionIdCapture, module structure)
- Direct codebase inspection — `src/renderer/services/TerminalSessionService.js` full file (atomic write, debounce, exports)
- Direct codebase inspection — `src/renderer/ui/components/TerminalManager.js` lines 1138-1175 (setActiveTerminal implementation)
- Direct codebase inspection — `src/renderer/state/terminals.state.js` full file (terminalsState shape)
- Direct codebase inspection — `src/renderer/events/HooksProvider.js` lines 100-115 (SESSION_START with sessionId)
- Phase 06 planning docs — 06-01-SUMMARY.md (established decisions carried forward)

### Secondary (MEDIUM confidence)
- STATE.md accumulated decisions — confirms `findClaudeTerminalForProject uses latest-terminal-ID heuristic`, `e.source === 'hooks'` guard
- CONTEXT.md for this phase — locked decisions from user discussion

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — pure internal codebase, no external dependencies added
- Architecture: HIGH — lazy require pattern verified in Phases 4, 5, 6 in same codebase
- Pitfalls: HIGH — circular dep risk verified by examining existing require directions; debounce gap verified in TerminalSessionService source

**Research date:** 2026-02-25
**Valid until:** Until TerminalManager or events/index.js are significantly refactored (stable internal API)
