---
phase: 6.3-remember-active-task-on-project-scope-to-restore-it-on-project-swap-and-app-restart
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/services/TerminalSessionService.js
  - src/renderer/ui/components/TerminalManager.js
autonomous: true
requirements:
  - SESS-01
  - SESS-02
must_haves:
  truths:
    - "When switching to a project, the terminal tab that was last active for that project is re-activated"
    - "When the app restarts, the last-active tab per project is restored after terminal recreation"
    - "If the remembered tab no longer exists (closed or index out of range), the first available tab is activated as fallback"
  artifacts:
    - path: "src/renderer/services/TerminalSessionService.js"
      provides: "activeTabIndex persistence in terminal-sessions.json"
      contains: "activeTabIndex"
    - path: "src/renderer/ui/components/TerminalManager.js"
      provides: "Active tab restoration in filterByProject"
      contains: "activeTabIndex"
  key_links:
    - from: "src/renderer/services/TerminalSessionService.js"
      to: "terminal-sessions.json"
      via: "saveTerminalSessionsImmediate writes activeTabIndex per project"
      pattern: "activeTabIndex.*tabIndex"
    - from: "src/renderer/ui/components/TerminalManager.js"
      to: "src/renderer/services/TerminalSessionService.js"
      via: "filterByProject reads activeTabIndex from loadSessionData"
      pattern: "loadSessionData.*activeTabIndex"
---

<objective>
Persist the active terminal tab index per project and restore it on project-swap and app restart.

Purpose: When a user switches between projects or restarts the app, they should land on exactly the tab they were last working in — not always the first tab.

Output: `activeTabIndex` field added to per-project session data, read by `filterByProject()` to restore the correct tab.
</objective>

<execution_context>
@C:/Users/uhgde/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/uhgde/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/6.3-remember-active-task-on-project-scope-to-restore-it-on-project-swap-and-app-restart/6.3-RESEARCH.md
@src/renderer/services/TerminalSessionService.js
@src/renderer/ui/components/TerminalManager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Persist activeTabIndex in TerminalSessionService</name>
  <files>src/renderer/services/TerminalSessionService.js</files>
  <action>
In `saveTerminalSessionsImmediate()`, add `activeTabIndex` computation to the per-project session data.

The function already iterates over `terminals` Map entries, groups them by `projectId`, and tracks `activeCwd` for the active terminal. Extend this:

1. Initialize `activeTabIndex: null` in the per-project object (alongside `activeCwd: null`).
2. Inside the iteration loop, after pushing a tab to `projectSessions[projectId].tabs`, check if the current terminal ID (`id`) matches `activeTerminalId`. If so, set `projectSessions[projectId].activeTabIndex = projectSessions[projectId].tabs.length - 1` (the index of the just-pushed tab).
3. The `activeTerminalId` is already available — it comes from `terminalsState.get().activeTerminal` which is already read in this function for `activeCwd`.

This is a 3-line addition: one line to init the field, one to compute the index, one assignment. The `activeTabIndex` is computed from the same iteration that builds `tabs[]`, so insertion order is guaranteed correct.

Also ensure the `merge-before-write` logic (which preserves explorer state from other projects) carries over `activeTabIndex` from existing data when a project has no terminals in the current session. This is already handled because `existingData.projects[pid]` is preserved for projects not in `projectSessions` — no change needed there.
  </action>
  <verify>
    <automated>npm run build:renderer && npm test</automated>
    <manual>Inspect dist/renderer.bundle.js for "activeTabIndex" string to confirm it's included in the bundle</manual>
  </verify>
  <done>terminal-sessions.json includes activeTabIndex (0-based integer or null) per project alongside activeCwd, computed from the active terminal's position in the tabs array</done>
</task>

<task type="auto">
  <name>Task 2: Restore active tab in filterByProject on project-swap and restart</name>
  <files>src/renderer/ui/components/TerminalManager.js</files>
  <action>
In `filterByProject()` (around line 2199-2201), replace the simple `firstVisibleId` fallback with an `activeTabIndex`-aware restore.

Current code (end of filterByProject):
```js
const activeTab = document.querySelector(`.terminal-tab[data-id="${getActiveTerminal()}"]`);
if (!activeTab || activeTab.style.display === 'none') {
  if (firstVisibleId) setActiveTerminal(firstVisibleId);
}
```

Replace with:
```js
const activeTab = document.querySelector(`.terminal-tab[data-id="${getActiveTerminal()}"]`);
if (!activeTab || activeTab.style.display === 'none') {
  let targetId = firstVisibleId;

  // Try to restore the last-active tab for this project
  const project = projects[projectIndex];
  if (project) {
    try {
      const { loadSessionData } = require('../../services/TerminalSessionService');
      const sessionData = loadSessionData();
      const savedIdx = sessionData?.projects?.[project.id]?.activeTabIndex;
      if (typeof savedIdx === 'number') {
        // Collect visible terminal IDs in Map iteration order (matches save order)
        const visibleIds = [];
        const terminals = terminalsState.get().terminals;
        terminals.forEach((td, id) => {
          const tab = document.querySelector(`.terminal-tab[data-id="${id}"]`);
          if (tab && tab.style.display !== 'none') {
            visibleIds.push(id);
          }
        });
        if (savedIdx < visibleIds.length) {
          targetId = visibleIds[savedIdx];
        }
      }
    } catch (e) { /* session data unavailable, use firstVisibleId */ }
  }

  if (targetId) setActiveTerminal(targetId);
}
```

Key implementation notes:
- Use lazy `require('../../services/TerminalSessionService')` inside the function body — follows the established circular-dep pattern used throughout the codebase (Phase 04, 05, 6.1 decisions).
- Collect visible IDs by checking DOM `display !== 'none'` — matches the same filtering logic already used in `filterByProject` to determine `firstVisibleId`.
- Bounds-check `savedIdx < visibleIds.length` — graceful fallback to `firstVisibleId` if index is out of range (per locked decision: "fall back to the first available tab").
- This handles BOTH project-swap and app-restart because: on restart, `filterByProject` is called via `setSelectedProjectFilter` for the `lastOpenedProjectId` (the research confirms this).
  </action>
  <verify>
    <automated>npm run build:renderer && npm test</automated>
    <manual>
1. Open the app with 2+ projects, each having 3+ terminal tabs.
2. In Project A, activate the 2nd tab. Switch to Project B, activate the 3rd tab.
3. Switch back to Project A — the 2nd tab should be active (not the 1st).
4. Switch to Project B — the 3rd tab should be active.
5. Restart the app — the last project's last-active tab should be selected.
6. Close 2 tabs in Project A so only 1 remains. Switch away and back — the remaining tab should be active (fallback works).
    </manual>
  </verify>
  <done>Switching projects restores the last-active tab for each project; app restart restores the last-active tab for the last-opened project; out-of-range index gracefully falls back to the first visible tab</done>
</task>

</tasks>

<verification>
1. `npm run build:renderer` succeeds — no syntax errors
2. `npm test` passes — no regressions
3. `grep -r "activeTabIndex" src/renderer/` shows occurrences in both TerminalSessionService.js and TerminalManager.js
4. Manual verification: project-swap restores correct tab; app restart restores correct tab; fallback works when saved tab is gone
</verification>

<success_criteria>
- activeTabIndex is persisted per-project in terminal-sessions.json on every save
- filterByProject reads activeTabIndex and activates the correct tab on project switch
- App restart restores the correct active tab for the last-opened project
- Missing or out-of-range index falls back to the first visible tab (no crash, no blank state)
</success_criteria>

<output>
After completion, create `.planning/phases/6.3-remember-active-task-on-project-scope-to-restore-it-on-project-swap-and-app-restart/6.3-01-SUMMARY.md`
</output>
