# Phase 6.3: Remember Active Tab on Project Scope - Research

**Researched:** 2026-02-26
**Domain:** Electron renderer state persistence / terminal tab management
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Active terminal tab only (not panels, scroll position, or modals)
- Stored per-project scope — each project remembers its own last active tab
- Auto-focus the remembered tab when switching to a project
- Identical behavior for both project-swap and app restart — no distinction
- If the remembered tab no longer exists (was closed), fall back to the first available tab

### Claude's Discretion
- Storage mechanism (extend existing session data or add new field)
- When to persist the active tab (on every tab switch, debounced, or on project-leave)
- How to identify tabs across restarts (terminal ID, index, or other stable identifier)

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

---

## Summary

Phase 6.3 adds per-project active-tab memory: when the user switches away from a project or quits the app, the currently-active terminal tab for each project is persisted, and that tab is re-activated when the user returns to the project.

The project already has a complete session-persistence infrastructure (`TerminalSessionService.js` + `terminal-sessions.json`). The existing `activeCwd` field tracks the active terminal's CWD to restore it across restarts. Phase 6.3 extends this by also restoring the correct tab on **project-swap** (switching projects in the sidebar) — something the current code does not handle at all, since `filterByProject()` simply activates `firstVisibleId` when the current active tab is not visible for the new project.

The implementation is small and self-contained: add a per-project `activeTabIndex` (ordinal position in the saved `tabs[]` array) to the session file, and restore that index when switching to a project. The `tabs[]` array is already ordered by creation sequence, making index a reliable cross-restart identifier as long as tab order is stable.

**Primary recommendation:** Extend `terminal-sessions.json` per-project payload with `activeTabIndex: number | null`. Write it in `saveTerminalSessionsImmediate()`. Restore it in two places: the startup restore loop in `renderer.js` (already partially does this via `activeCwd`) and `filterByProject()` in `TerminalManager.js` (project-swap path). Index-based identification is preferred over CWD because multiple tabs can share the same CWD.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| None | — | No new dependencies needed | Feature is pure logic on existing data structures |

### Supporting
| File | Purpose | Role in this phase |
|------|---------|-------------------|
| `src/renderer/services/TerminalSessionService.js` | Persist/load `terminal-sessions.json` | Add `activeTabIndex` write |
| `renderer.js` (startup restore loop, lines 183–226) | Restores terminals on cold start | Already handles `activeCwd` — extend to use `activeTabIndex` |
| `src/renderer/ui/components/TerminalManager.js` `filterByProject()` (line 2102) | Filters visible tabs when project is selected | Extend to restore saved active tab |
| `src/renderer/state/terminals.state.js` `setActiveTerminal()` | Sets active terminal in state | Called unchanged |

---

## Architecture Patterns

### Existing Session Data Structure (terminal-sessions.json)

```json
{
  "version": 1,
  "savedAt": "...",
  "lastOpenedProjectId": "project-abc",
  "projects": {
    "project-abc": {
      "tabs": [
        { "cwd": "/path", "isBasic": false, "mode": "terminal", "claudeSessionId": null, "name": null },
        { "cwd": "/path", "isBasic": false, "mode": "chat",     "claudeSessionId": "ses-123", "name": "My Chat" }
      ],
      "activeCwd": "/path",
      "explorer": { ... }
    }
  }
}
```

After phase 6.3, the per-project payload adds:

```json
{
  "tabs": [ ... ],
  "activeCwd": "/path",
  "activeTabIndex": 1,
  "explorer": { ... }
}
```

### Pattern 1: Index-Based Tab Identification

**What:** Store the ordinal index of the active tab within `tabs[]` (0-based). Tabs are saved in insertion order — matching the DOM tab order — so index is stable.

**Why not terminal ID:** Runtime terminal IDs (Map keys) are ephemeral integers that reset each session. They have no meaning across restarts.

**Why not CWD:** Multiple tabs can share the same CWD (e.g., two Claude sessions in the same project). The current `activeCwd` approach has a collision risk. `activeTabIndex` is unambiguous.

**When to persist:**
- On every tab switch (inside `setActiveTerminal()` in TerminalManager.js) — calls `saveTerminalSessions()` which debounces at 2000ms. This is the lowest-friction option because `saveTerminalSessions()` is already called there implicitly via existing subscriptions.
- Alternatively: immediately in `saveTerminalSessionsImmediate()` by reading the current `activeTerminal` from state (already done for `activeCwd` — just compute index from the same data).

The cleaner approach is **option B**: compute `activeTabIndex` inside `saveTerminalSessionsImmediate()` from the existing iteration, since that function already knows the tab order and which terminal is active. No new save triggers needed.

### Pattern 2: Restore on Project-Swap (filterByProject)

`filterByProject()` (TerminalManager.js line 2102) is called whenever the user clicks a project in the sidebar. Its current logic at the end:

```js
// Current (line 2199–2201): falls back to firstVisibleId
const activeTab = document.querySelector(`.terminal-tab[data-id="${getActiveTerminal()}"]`);
if (!activeTab || activeTab.style.display === 'none') {
  if (firstVisibleId) setActiveTerminal(firstVisibleId);
}
```

Phase 6.3 replaces this fallback with: look up `activeTabIndex` from `loadSessionData()` for the selected project, find the Nth terminal in `visibleTerminals` order, and call `setActiveTerminal(thatId)`. If not found (index out of range or no saved data), fall back to `firstVisibleId`.

```js
// Proposed (pseudocode):
const projectId = project?.id;
let restoredId = null;
if (projectId) {
  const sessionData = loadSessionData();
  const savedIdx = sessionData?.projects?.[projectId]?.activeTabIndex;
  if (typeof savedIdx === 'number') {
    // collect visibleTerminals in iteration order
    const visible = [];
    terminals.forEach((td, id) => { if (shouldShow(td)) visible.push(id); });
    restoredId = visible[savedIdx] ?? null;
  }
}
if (!activeTab || activeTab.style.display === 'none') {
  setActiveTerminal(restoredId ?? firstVisibleId);
}
```

### Pattern 3: Restore on App Restart

The startup loop in `renderer.js` (line 206–217) already calls `TerminalManager.setActiveTerminal(activeId)` using `activeCwd`. The `activeTabIndex` can be used there as a more reliable alternative or supplement:

```js
// After restoring all tabs for a project:
const tabsForProject = [];
terminals.forEach((td, id) => {
  if (td.project?.id === projectId) tabsForProject.push(id);
});
const savedIdx = saved.activeTabIndex;
const restoredId = (typeof savedIdx === 'number' && tabsForProject[savedIdx]) || null;
// also try activeCwd as existing fallback
if (restoredId) TerminalManager.setActiveTerminal(restoredId);
```

Note: The startup restore processes projects sequentially. The **last project processed** (`lastOpenedProjectId`) is selected via `setSelectedProjectFilter` + `filterByProject` after the loop. Since `filterByProject` will now restore the correct tab for the newly selected project, the startup path may already be covered by the project-swap path — meaning `filterByProject` handles both cases uniformly.

### Anti-Patterns to Avoid

- **Storing runtime terminal IDs:** Ephemeral, meaningless across restarts.
- **Calling `loadSessionData()` on every tab switch:** Session file is read on disk each call. Only call it in `filterByProject()` — it runs on project-switch, not per-frame.
- **Adding a separate storage file:** Phase 6.3 should extend `terminal-sessions.json`, which already groups per-project data and uses atomic writes.
- **Overwriting `activeCwd`:** Keep `activeCwd` as is — it provides a redundant cross-check. Add `activeTabIndex` alongside it.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Debounced save | Custom timer | Existing `saveTerminalSessions()` (2000ms debounce) | Already battle-tested |
| Atomic write | Custom write | Existing `saveTerminalSessionsImmediate()` with `.tmp` + rename | Already handles atomicity |
| Session load | Disk read | Existing `loadSessionData()` | Already validates structure, handles missing file |

---

## Common Pitfalls

### Pitfall 1: Index Computed from Wrong Iteration Order
**What goes wrong:** `terminals` is a `Map` — insertion order is preserved in JS, but the visible order in `filterByProject` is determined by the same iteration. If tabs are created in a different order than they appear in `tabs[]` in the session file, the index maps to the wrong tab.

**Why it happens:** The restore loop creates tabs sequentially from `saved.tabs`, so Map insertion order matches `tabs[]` order. But if a user creates a tab mid-session and it appears in a different position, the index computed at save time and the position at restore time must agree.

**How to avoid:** Compute `activeTabIndex` as the position of the active terminal within `tabs[]` array being written in `saveTerminalSessionsImmediate()`, not as a position in the Map. Since `tabs` is built by iterating the Map and pushing in order, the index of the active terminal in the resulting `tabs[]` array is the correct value to save.

**Concretely:** In `saveTerminalSessionsImmediate()`, when pushing to `projectSessions[projectId].tabs`, track which push index corresponds to the active terminal:

```js
let activeTabIndex = null;
for (const [id, td] of terminals) {
  if (!td.project?.id) continue;
  const projectId = td.project.id;
  if (!projectSessions[projectId]) {
    projectSessions[projectId] = { tabs: [], activeCwd: null, activeTabIndex: null };
  }
  const tab = { ... };
  const tabIndex = projectSessions[projectId].tabs.length;
  projectSessions[projectId].tabs.push(tab);
  if (id === activeTerminalId) {
    projectSessions[projectId].activeCwd = tab.cwd;
    projectSessions[projectId].activeTabIndex = tabIndex;
  }
}
```

### Pitfall 2: filterByProject Called Before Session Data Loaded
**What goes wrong:** On cold start, `filterByProject` is called as part of restoring `lastOpenedProjectId` (line 223–225 in renderer.js). At that point, all tabs are newly created. Session data is already loaded in memory, so `loadSessionData()` is a disk read each call — harmless but redundant.

**How to avoid:** Pass session data as a parameter to `filterByProject`, or cache it in a module-level variable during the startup restore window. The simplest approach: `loadSessionData()` is already cheap (synchronous, ~1ms), so calling it inside `filterByProject` is fine.

### Pitfall 3: All Tabs Share the Same CWD
**What goes wrong:** Current `activeCwd` restore logic matches on CWD. If two tabs have `cwd === "/my/project"`, both match and the last one wins.

**How to avoid:** Phase 6.3 introduces `activeTabIndex` as a precise replacement. Keep `activeCwd` for backward compatibility but prefer `activeTabIndex` when available.

### Pitfall 4: Remembered Index out of Bounds
**What goes wrong:** User had 3 tabs, activeTabIndex=2. On next launch, only 1 tab restored (project path no longer exists for others). Index 2 doesn't exist.

**How to avoid:** Always bounds-check: `visibleTerminals[savedIdx] ?? firstVisibleId`.

---

## Code Examples

### Writing activeTabIndex in saveTerminalSessionsImmediate()

```js
// Source: TerminalSessionService.js — saveTerminalSessionsImmediate()
for (const [id, td] of terminals) {
  if (!td.project?.id) continue;
  const projectId = td.project.id;
  if (!projectSessions[projectId]) {
    projectSessions[projectId] = { tabs: [], activeCwd: null, activeTabIndex: null };
  }
  const tab = {
    cwd: td.cwd || td.project.path,
    isBasic: td.isBasic || false,
    mode: td.mode || 'terminal',
    claudeSessionId: td.claudeSessionId || null,
    name: td.name || null,
  };
  const tabIndex = projectSessions[projectId].tabs.length;
  projectSessions[projectId].tabs.push(tab);
  if (id === activeTerminalId) {
    projectSessions[projectId].activeCwd = tab.cwd;
    projectSessions[projectId].activeTabIndex = tabIndex;
  }
}
```

### Restoring in filterByProject() (project-swap path)

```js
// Source: TerminalManager.js — filterByProject(), after building visible terminal list
const project = projects[projectIndex];
const currentActiveId = getActiveTerminal();
const currentActiveTab = document.querySelector(`.terminal-tab[data-id="${currentActiveId}"]`);

if (!currentActiveTab || currentActiveTab.style.display === 'none') {
  let targetId = firstVisibleId; // default fallback

  if (project) {
    try {
      const { loadSessionData } = require('../../services/TerminalSessionService');
      const sessionData = loadSessionData();
      const savedIdx = sessionData?.projects?.[project.id]?.activeTabIndex;
      if (typeof savedIdx === 'number') {
        // Collect visible terminal IDs in Map iteration order
        const visibleIds = [];
        const terminals = terminalsState.get().terminals;
        terminals.forEach((td, id) => {
          const shouldShow = projectIndex === null || (td.project && (
            td.project.path === project.path ||
            (td.parentProjectId && td.parentProjectId === project.id)
          ));
          if (shouldShow) visibleIds.push(id);
        });
        targetId = visibleIds[savedIdx] ?? firstVisibleId;
      }
    } catch (e) { /* session data unavailable */ }
  }

  if (targetId) setActiveTerminal(targetId);
}
```

### Restoring on App Restart (startup loop in renderer.js)

The startup loop already calls `TerminalManager.setActiveTerminal(activeId)` then at the end calls `filterByProject(idx)` for `lastOpenedProjectId`. Since `filterByProject` will now restore the correct tab using `activeTabIndex`, the startup path for the **last opened project** is handled automatically.

For **other projects** (not last opened), tabs are created but none are activated, which is correct — they are hidden until the user selects them.

---

## Open Questions

1. **Should activeTabIndex also be saved on project-leave (not just on timer)?**
   - What we know: `saveTerminalSessions()` is called from multiple places already (tab close, terminal create, etc.). The 2000ms debounce means the last active tab is captured within 2 seconds of a tab switch.
   - What's unclear: If the user switches projects immediately after switching tabs (within 2s), the debounce might not have fired yet.
   - Recommendation: Also call `saveTerminalSessionsImmediate()` (or at minimum reset the debounce) when the user switches projects (in `onFilterTerminals` callback at renderer.js line 1402). Currently `saveTerminalSessions()` is already called there — verify this is the debounced version. If so, no change needed.

2. **Does filterByProject need the project ID or index?**
   - What we know: `filterByProject(projectIndex)` receives an index into `projects[]`. The project object is retrieved inside the function. The session data is keyed by `project.id` (string).
   - What's unclear: Nothing — project ID is available as `projects[projectIndex].id` inside the function.
   - Recommendation: Access `project?.id` from the already-retrieved `project` variable inside `filterByProject`.

---

## Sources

### Primary (HIGH confidence)
- Direct codebase analysis — `src/renderer/services/TerminalSessionService.js` (full read)
- Direct codebase analysis — `src/renderer/state/terminals.state.js` (full read)
- Direct codebase analysis — `src/renderer/state/projects.state.js` (full read)
- Direct codebase analysis — `renderer.js` lines 150–235, 1550–1576 (session restore + project-change subscription)
- Direct codebase analysis — `src/renderer/ui/components/TerminalManager.js` lines 1–200, 1166–1214, 2100–2220 (filterByProject, setActiveTerminal)
- Direct codebase analysis — `src/renderer/ui/components/ProjectList.js` lines 660–771 (project click handling)

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — no new deps, pure extension of existing patterns
- Architecture: HIGH — all code paths directly inspected
- Pitfalls: HIGH — derived from direct analysis of the existing `activeCwd` approach and its known limitations

**Research date:** 2026-02-26
**Valid until:** 2026-03-28 (stable codebase)
