---
phase: 5.1-save-explorer-state-within-app-starts-and-remember-scroll-position
plan: 01
subsystem: renderer/ui/components, renderer/services
tags: [file-explorer, scroll-persistence, cold-start-fix, state-persistence]
dependency_graph:
  requires: [Phase 5 explorer state infrastructure, Phase 4 terminal session persistence]
  provides: [_skipExplorerCapture flag, scrollTop in explorer state, counter-based async scroll restore]
  affects: [FileExplorer.js, TerminalSessionService.js]
tech_stack:
  added: []
  patterns: [counter-based async completion tracking, _isRestoring guard flag, debounced scroll save]
key_files:
  created: []
  modified:
    - src/renderer/ui/components/FileExplorer.js
    - src/renderer/services/TerminalSessionService.js
decisions:
  - _isRestoring flag set at restoreState entry, cleared inside _applyScrollTop after 100ms — lets programmatic scroll event pass debounce window without triggering spurious save
  - Counter-based remaining counter in restoreState rather than MutationObserver — deterministic (we know the load count), integrates cleanly without cleanup
  - _applyScrollTop uses requestAnimationFrame so DOM is painted before measuring scrollHeight/clientHeight for clamp calculation
  - setSkipExplorerCapture exported from TerminalSessionService — renderer.js (Plan 02) will call it around the restore loop
  - Scroll listener attached once in init() (not in attachListeners()) — prevents multiple listener accumulation across renders
metrics:
  duration: ~2 minutes
  completed: 2026-02-25
  tasks_completed: 2
  files_modified: 2
---

# Phase 5.1 Plan 01: Fix Cold-Start Explorer State Overwrite and Add Scroll Persistence Summary

**One-liner:** Added `_skipExplorerCapture` guard in TerminalSessionService and counter-based async scroll restore with `_isRestoring` debounce guard in FileExplorer.

## What Was Built

### Task 1: `_skipExplorerCapture` guard in TerminalSessionService.js

Added a module-level flag `_skipExplorerCapture` (default `false`) and exported `setSkipExplorerCapture(value)`. In `saveTerminalSessionsImmediate`, the `FileExplorer.getState()` call is now wrapped in `if (!_skipExplorerCapture)`. When the flag is `true`, the merge-before-write logic preserves the existing explorer state from disk instead of overwriting it with the live (potentially empty) state.

This fixes the cold-start regression: during the terminal restore loop in `renderer.js` (Plan 02 will wire this), `saveTerminalSessions()` is triggered by each `createTerminal` call. At that moment, `FileExplorer.getState()` returns empty state because the explorer hasn't been restored yet. The guard prevents this from overwriting the valid saved state on disk.

### Task 2: Scroll position persistence in FileExplorer.js

**`_isRestoring` flag:** Module-level flag set to `true` at the start of `restoreState()`, cleared inside `_applyScrollTop()` after a 100ms delay. Prevents the debounced scroll listener from firing a save during programmatic scroll restoration.

**`getState()` extended:** Added `scrollTop: treeEl ? treeEl.scrollTop : 0` to the returned object.

**`_applyScrollTop(scrollTop)` helper:** Uses `requestAnimationFrame` to measure scroll bounds after DOM paint, clamps `scrollTop` to `max(0, scrollHeight - clientHeight)`, sets `treeEl.scrollTop`, then clears `_isRestoring` after 100ms.

**`restoreState()` refactored:** Counter-based async loading — `remaining` counter tracks in-flight `readDirectoryAsync` calls. `_applyScrollTop(scrollTop)` is called when `remaining` reaches 0 (all folders loaded). This ensures scroll position is restored after the tree content is fully rendered, not before.

**Debounced scroll listener in `init()`:** Attaches once (not on every `render()`) with a 500ms debounce, guarded by `!_isRestoring`.

## Commits

| Task | Commit | Description |
|------|--------|-------------|
| Task 1 | `0bffbf0` | feat(5.1-01): add _skipExplorerCapture guard in TerminalSessionService |
| Task 2 | `6bafa46` | feat(5.1-01): add scroll position persistence to FileExplorer |

## Deviations from Plan

None — plan executed exactly as written.

## Decisions Made

1. **`_isRestoring` cleared after 100ms delay** — The programmatic `scrollTop` assignment fires a synchronous scroll event. The 100ms window ensures the debounced scroll handler (500ms) never sees this event as a user scroll, preventing a spurious write of the restored position back to disk.

2. **Scroll listener in `init()` not `attachListeners()`** — `attachListeners()` is called on every `render()` cycle; attaching a scroll listener there would accumulate multiple handlers. `init()` is called once, making it the correct attachment point.

3. **Counter-based async pattern over MutationObserver** — The exact number of async loads is known at the start of `restoreState()`, making the counter approach deterministic and requiring no cleanup code.

4. **`_applyScrollTop` handles `scrollTop = 0` gracefully** — Early return when `!scrollTop` also clears `_isRestoring` to avoid leaving the flag stuck as `true` when there's nothing to scroll to.

## Self-Check: PASSED

- `src/renderer/ui/components/FileExplorer.js` — modified, contains `_isRestoring`, `_applyScrollTop`, `scrollTop` in `getState`, counter-based `restoreState`, `debouncedScrollSave` in `init`
- `src/renderer/services/TerminalSessionService.js` — modified, contains `_skipExplorerCapture`, `setSkipExplorerCapture`, guard in `saveTerminalSessionsImmediate`, export
- Commits `0bffbf0` and `6bafa46` exist in git log
- `npm run build:renderer` passes
- `npm test` — 262/262 tests pass
