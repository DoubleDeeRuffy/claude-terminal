# Phase 5.1: Save Explorer-State within app starts and remember Scroll-Position - Research

**Researched:** 2026-02-25
**Domain:** Electron renderer — FileExplorer state persistence, scroll position, async DOM timing
**Confidence:** HIGH

## Summary

Phase 5.1 has two distinct goals. First, fix a regression where Phase 5's explorer state (expanded folders, panel visibility) does not survive cold-start app restarts — even though the save/restore infrastructure was built and verified in Phase 5. Second, add scroll position persistence for the file tree (`#file-explorer-tree`), per-project, with the same unified restore path already used by Phase 5.

The infrastructure from Phase 5 is already correct and complete at the IPC and service layer. The cold-start bug is almost certainly a timing issue: `setRootPath` is called inside `projectsState.subscribe`, but during the startup restore path the subscriber fires while the file tree is still being populated asynchronously (each `getOrLoadFolder` call spawns an async IPC read and calls `render()` when done). Scroll position must be restored *after* the last async folder load completes and `render()` runs — not at the same time as `restoreState()`.

No new dependencies are required. All changes are confined to `src/renderer/ui/components/FileExplorer.js` and `src/renderer/services/TerminalSessionService.js`, following identical patterns to Phase 5.

**Primary recommendation:** Diagnose the cold-start bug by tracing whether `restoreState()` is actually called during startup (not just on switch), then add scroll position as a field in `getState()`/`restoreState()`, restored after async folder loads complete via a post-render callback.

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Scroll position scope
- File tree scroll only — no editor previews or other scrollable containers
- Per-project scroll position — each project remembers its own scroll position independently

#### Restore behavior
- Unified flow for both app startup and project switch — same code path
- Wait for folder expansion to complete, then restore scroll position (expand first, scroll after DOM settles)
- Instant scrollTop set — no animation or visual feedback, feels like explorer never changed
- If saved position exceeds current tree height, clamp to max scroll (scroll to end)

#### Save triggers
- Debounced on scroll events (e.g., 500ms debounce) — captures latest position without write spam
- Also save on app close / before-quit — flush any pending scroll position to prevent data loss
- Save on project switch (existing Phase 5 pattern)

#### Persistence
- Disk persistence — survives app restarts and crashes
- Stored alongside existing explorer state data (Phase 5's storage mechanism)

#### App restart fix
- Explorer state (expanded folders, panel visibility from Phase 5) is lost on cold start — this must be fixed
- Root cause needs investigation: Phase 5 saves state but startup restore may not be reading it back

### Claude's Discretion
- Debounce interval tuning (500ms suggested, adjust as needed)
- DOM settle detection strategy (MutationObserver, requestAnimationFrame, or setTimeout)
- Exact integration point with Phase 5's existing save/restore infrastructure

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope
</user_constraints>

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| (none new) | — | All needed APIs already present | Phase 5 infrastructure is complete; no new packages required |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `debounce` (internal util) | — | Debounce scroll saves | Already used in FileExplorer for search; same pattern |
| `fs` (via `window.electron_nodeModules`) | — | Atomic writes | Already used by TerminalSessionService |

**Installation:** None required.

---

## Architecture Patterns

### Existing Infrastructure (from Phase 5)

```
FileExplorer.getState()     → { expandedPaths[], panelVisible }
FileExplorer.restoreState() → re-expands folders, sets panel visibility
FileExplorer.setRootPath(path, savedState) → clears state, calls restoreState() if savedState given
FileExplorer._triggerSave() → lazy-requires TerminalSessionService.saveTerminalSessions()

TerminalSessionService.saveTerminalSessionsImmediate()
  → merges existing disk data, then sets projects[currentProjectId].explorer = FileExplorer.getState()

renderer.js projectsState.subscribe()
  → loadSessionData() → sessionData.projects[project.id].explorer → FileExplorer.setRootPath(path, explorerState)
```

The JSON storage shape in `terminal-sessions.json` per project is:
```json
{
  "projects": {
    "<projectId>": {
      "tabs": [...],
      "explorer": {
        "expandedPaths": ["C:/path/to/folder", "..."],
        "panelVisible": true
      }
    }
  }
}
```

Phase 5.1 will extend `explorer` to:
```json
{
  "expandedPaths": [...],
  "panelVisible": true,
  "scrollTop": 312
}
```

### Pattern 1: Cold-Start Bug Diagnosis

**What:** Phase 5's `05-02-SUMMARY.md` documents that startup restore works via Phase 4's `setSelectedProjectFilter(idx)` call which fires the `projectsState.subscribe` callback. But the startup restore in `renderer.js` lines 219-224 calls `setSelectedProjectFilter(idx)` *after* the terminal restore loop completes. If the FileExplorer subscriber fires at this moment, `setRootPath` is called, which calls `restoreState`, which calls `getOrLoadFolder` for each saved path — but those are all async IPC calls. The `render()` eventually fires once each async load completes. There is no known timing bug here at the save/restore mechanism level.

**Likely actual root cause:** The `setRootPath` function has an early-return guard: `if (rootPath === projectPath) return;`. On cold start, when `setSelectedProjectFilter(idx)` is called the *first* time, `rootPath` is null so it proceeds correctly. However, the file `terminal-sessions.json` is read fresh each time inside the subscriber, and the `explorerState` object is passed to `setRootPath`. This should work correctly unless:
1. The subscriber is firing *before* the startup `setSelectedProjectFilter` call — e.g., some earlier code path that sets `selectedProjectFilter` to the same value, causing the later call to be a no-op due to the guard, or
2. The `terminal-sessions.json` file is being overwritten (with blank explorer state) by the terminal restore loop before the subscriber reads it.

**Root cause candidate 1 (HIGH likelihood):** The terminal restore loop at lines 179-229 creates terminals and calls `setSelectedProjectFilter(idx)` at line 222. During terminal creation, `saveTerminalSessions()` is triggered (each `createTerminal` call causes a save). `saveTerminalSessionsImmediate` at that point reads `FileExplorer.getState()` — but the FileExplorer has just had `rootPath` set to null (or set to the project path but not yet restored), so `getState()` returns `{ expandedPaths: [], panelVisible: false/true }` — an empty state. This **overwrites the saved explorer state on disk** before the restore subscriber gets a chance to read it. On the next call to `loadSessionData()` in the subscriber, the explorer key is gone.

**Root cause candidate 2 (MEDIUM likelihood):** The `projectsState.subscribe` for FileExplorer fires whenever `selectedProjectFilter` changes. During `initializeState()`, if projects are loaded with a `selectedProjectFilter` already set, the subscriber may fire with a stale `explorerState = null` before `setSelectedProjectFilter(idx)` is called in the restore path.

**Root cause candidate 3 (LOW likelihood):** `restoreState()` itself fails silently — `getOrLoadFolder` is async and the root path check `isPathSafe` may be returning false for Windows paths with mixed separators.

### Pattern 2: Scroll Position Persistence

**What:** Add `scrollTop` to `getState()` capture and `restoreState()` application.

**The scrollable element:** `#file-explorer-tree` (CSS: `overflow-y: auto`). `scrollTop` is the correct property.

**Save:** Attach a debounced (500ms) scroll listener to `#file-explorer-tree` that calls `_triggerSave()`. This is the same pattern as the existing save triggers in `toggleFolder`, `show`, and `hide`.

**Restore timing:** Scroll must be restored *after* folder expansion async loads complete. The challenge is that `getOrLoadFolder` is fire-and-forget — each one calls `render()` when its async IPC completes. There is no single "all expansions done" callback.

**Strategies for DOM settle detection:**

Option A — **Counter-based**: In `restoreState`, count the number of paths to expand. Track a callback `onRestoreComplete` — after each async load completes (in `getOrLoadFolder`'s `.then()`), decrement counter. When counter reaches 0, apply scrollTop.

Option B — **MutationObserver with idle timeout**: Observe `#file-explorer-tree` subtree mutations; after a period of no mutations (e.g., 100ms), apply scrollTop. More resilient to unknown load counts. Requires cleanup.

Option C — **Fixed setTimeout after restoreState**: Set a timeout of 200–300ms after calling `restoreState(savedState)` in `setRootPath`. Simple but fragile with slow filesystems.

**Recommendation (Claude's Discretion):** Option A (counter-based) is the most deterministic because we know exactly how many async loads to wait for. It integrates cleanly without a separate observer. Implementation: pass a `onAllLoaded` callback to `restoreState`; after restoreState initiates all loads, a post-load callback fires `scrollEl.scrollTop = Math.min(savedScrollTop, scrollEl.scrollHeight - scrollEl.clientHeight)`.

**Clamp logic:**
```js
const treeEl = document.getElementById('file-explorer-tree');
if (treeEl && savedState.scrollTop > 0) {
  const maxScroll = treeEl.scrollHeight - treeEl.clientHeight;
  treeEl.scrollTop = Math.min(savedState.scrollTop, Math.max(0, maxScroll));
}
```

### Pattern 3: Before-Quit Flush

The context requires saving on app close to flush any pending debounced scroll position.

The existing `app-will-quit` IPC path calls `saveAndShutdown()` in `renderer.js` (line 3749), which is `timeTracking.state.saveAndShutdown()` — it only handles time tracking. A separate flush for `saveTerminalSessionsImmediate()` (which captures FileExplorer state including scrollTop) must be added to the same `onWillQuit` handler and `beforeunload` handler.

**Existing pattern from Phase 9 research:** The `will-quit` event fires before the process exits. Calling `saveTerminalSessionsImmediate()` synchronously in the quit handler is safe here since it uses synchronous `fs.writeFileSync` internally.

```js
// In renderer.js, extend existing onWillQuit handler:
api.lifecycle.onWillQuit(() => {
  const { saveAndShutdown } = require('./src/renderer');
  saveAndShutdown();
  // Flush any pending explorer state (including scrollTop)
  const { saveTerminalSessionsImmediate } = require('./src/renderer/services/TerminalSessionService');
  saveTerminalSessionsImmediate();
});
```

### Anti-Patterns to Avoid

- **Saving scrollTop during restoreState:** The scroll position is being set programmatically — the scroll listener must be guarded to not fire during restore (use a flag `_isRestoring` or detach/reattach listener).
- **Restoring scrollTop before folder loads complete:** Will always scroll to 0 because the tree is empty until async loads finish.
- **Using `localStorage` for scrollTop:** The existing width persistence uses `localStorage.getItem('file-explorer-width')` — but scroll position is per-project and project IDs are not stable across machines, so disk storage (terminal-sessions.json) is correct.
- **Overwriting disk explorer state during terminal restore:** Root cause candidate 1 — calling `saveTerminalSessions()` during terminal creation overwrites the saved `explorer` key before it can be restored.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Debounce | Custom timer logic | Existing `debounce` from `../../utils/dom` | Already imported in FileExplorer.js |
| Atomic writes | Direct `writeFileSync` | Existing `writeSessionsFile` in TerminalSessionService | Already uses tmp+rename pattern |
| Scroll listener | Any framework | Native `addEventListener('scroll', ...)` | No library needed; DOM scroll events are reliable |

---

## Common Pitfalls

### Pitfall 1: Save During Restore Overwrites Saved State

**What goes wrong:** During terminal restore at startup, `createTerminal` triggers `saveTerminalSessions()`. At that moment, `FileExplorer.getState()` returns empty state because the explorer hasn't been restored yet. This writes `explorer: { expandedPaths: [], panelVisible: false }` to disk, losing the saved state before the subscriber gets to read it.

**Why it happens:** `saveTerminalSessionsImmediate` always calls `FileExplorer.getState()` for the current project, regardless of whether a restore is in progress.

**How to avoid:** In `saveTerminalSessionsImmediate`, only call `FileExplorer.getState()` if the explorer has been fully initialized. A simple guard: check if `FileExplorer.isRestoring()` or use the existing `panelVisible` check (if `isVisible === false` AND `rootPath` is set AND we're in the startup phase, skip explorer state capture). Alternatively, skip the `FileExplorer.getState()` call entirely during the terminal restore loop by adding a flag in TerminalSessionService: `let _skipExplorerCapture = false`.

**Warning signs:** After restart, explorer state is always empty even though it was saved correctly before the previous quit.

### Pitfall 2: ScrollTop Save Fires During Programmatic Scroll

**What goes wrong:** When `restoreState` sets `scrollTop` programmatically, the `scroll` event fires, triggering the debounced save with the correct value — but during the brief window when the tree is not fully rendered, `scrollTop` might read back as 0 (if the browser hasn't laid out the content yet).

**Why it happens:** Setting `scrollTop` before the async folder loads complete causes the browser to clamp it to 0 (no scroll content yet). The debounced save then writes 0 to disk.

**How to avoid:** Apply `scrollTop` only after folder loads complete (Pattern 2 above). Guard the scroll listener with a `_isRestoring` flag to suppress saves during the restore window.

**Warning signs:** Saved scroll position is always 0 after a restart.

### Pitfall 3: setRootPath Early-Return Guard

**What goes wrong:** `setRootPath` has `if (rootPath === projectPath) return;` as its first line. If the subscriber is called twice with the same project path (e.g., during startup when both an initial state fire AND the explicit `setSelectedProjectFilter` call happen), the second call is silently ignored — including the `savedState` parameter.

**Why it happens:** State subscribers can fire multiple times; `projectsState.subscribe` fires on any `projectsState.set()` call, not just changes to `selectedProjectFilter`.

**How to avoid:** The existing guard is intentional to prevent redundant re-renders. The startup restore must ensure `setRootPath` is called exactly once with the correct `savedState`. Since `rootPath` is null at startup, the first call will always proceed. No change needed for this guard — just ensure startup doesn't call `setSelectedProjectFilter` with the target project twice before the subscriber fires.

---

## Code Examples

### Extending getState() to include scrollTop

```js
// src/renderer/ui/components/FileExplorer.js
function getState() {
  const treeEl = document.getElementById('file-explorer-tree');
  return {
    expandedPaths: [...expandedFolders.keys()].filter(p => {
      const entry = expandedFolders.get(p);
      return entry && entry.loaded;
    }),
    panelVisible: isVisible,
    scrollTop: treeEl ? treeEl.scrollTop : 0
  };
}
```

### Restoring scrollTop after async loads

```js
// src/renderer/ui/components/FileExplorer.js
function restoreState(savedState) {
  const { expandedPaths = [], panelVisible = true, scrollTop = 0 } = savedState;

  // ... existing panel visibility restore ...

  if (expandedPaths.length === 0) {
    render();
    _applyScrollTop(scrollTop);
    return;
  }

  let remaining = 0;
  for (const folderPath of expandedPaths) {
    try {
      if (!fs.existsSync(folderPath)) continue;
      if (!isPathSafe(folderPath)) continue;
      const entry = expandedFolders.get(folderPath);
      if (!entry) {
        remaining++;
        expandedFolders.set(folderPath, { children: [], loaded: false, loading: true });
        readDirectoryAsync(folderPath).then(children => {
          const e = expandedFolders.get(folderPath);
          if (e) { e.children = children; e.loaded = true; e.loading = false; }
          remaining--;
          render();
          if (remaining === 0) _applyScrollTop(scrollTop);
        }).catch(() => {
          remaining--;
          const e = expandedFolders.get(folderPath);
          if (e) { e.loaded = true; e.loading = false; }
          render();
          if (remaining === 0) _applyScrollTop(scrollTop);
        });
      }
    } catch (e) { /* silently skip */ }
  }

  if (remaining === 0) {
    render();
    _applyScrollTop(scrollTop);
  }
}

function _applyScrollTop(scrollTop) {
  if (!scrollTop) return;
  const treeEl = document.getElementById('file-explorer-tree');
  if (!treeEl) return;
  const maxScroll = Math.max(0, treeEl.scrollHeight - treeEl.clientHeight);
  treeEl.scrollTop = Math.min(scrollTop, maxScroll);
}
```

### Debounced scroll listener in init()

```js
// src/renderer/ui/components/FileExplorer.js
let _isRestoring = false; // guard flag

function attachListeners() {
  // ... existing listeners ...

  const treeEl = document.getElementById('file-explorer-tree');
  if (treeEl) {
    const debouncedScrollSave = debounce(() => {
      if (!_isRestoring) _triggerSave();
    }, 500);
    treeEl.addEventListener('scroll', debouncedScrollSave);
  }
}
```

### Before-quit flush in renderer.js

```js
// renderer.js — extend existing onWillQuit handler
api.lifecycle.onWillQuit(() => {
  const { saveAndShutdown } = require('./src/renderer');
  saveAndShutdown();
  const { saveTerminalSessionsImmediate } = require('./src/renderer/services/TerminalSessionService');
  saveTerminalSessionsImmediate();
});

window.addEventListener('beforeunload', () => {
  const { saveAndShutdown } = require('./src/renderer');
  saveAndShutdown();
  const { saveTerminalSessionsImmediate } = require('./src/renderer/services/TerminalSessionService');
  saveTerminalSessionsImmediate();
});
```

---

## Open Questions

1. **Exact root cause of cold-start bug**
   - What we know: Phase 5 save/restore infrastructure is verified working for project switches. Cold start fails. The `saveTerminalSessionsImmediate` call during terminal restore is the most likely culprit because it captures `FileExplorer.getState()` at a moment when the explorer has no loaded state.
   - What's unclear: Whether the subscriber fires once or twice on startup, and whether the overwrite timing is confirmed.
   - Recommendation: During plan execution, add a console.log trace to verify whether `explorerState` is null when passed to `setRootPath` during startup. If null, confirm that `saveTerminalSessionsImmediate` is being called during the terminal restore loop and writing an empty explorer state.

2. **restoreState refactor vs. using existing getOrLoadFolder**
   - What we know: Current `restoreState` calls `getOrLoadFolder` which internally calls `readDirectoryAsync` and fires its own `render()`. The new scroll-restore pattern needs to intercept the "all loaded" moment.
   - What's unclear: Whether the refactor of `restoreState` to manage async loading directly (replacing the `getOrLoadFolder` call with inline logic) introduces regression risk for the existing expand behavior.
   - Recommendation: Keep the refactor minimal — use the counter-based pattern inside `restoreState` only when `scrollTop > 0`, otherwise fall back to existing `getOrLoadFolder` calls.

---

## Sources

### Primary (HIGH confidence)
- Direct code reading: `src/renderer/ui/components/FileExplorer.js` (full file, 1215 lines)
- Direct code reading: `src/renderer/services/TerminalSessionService.js` (full file, 182 lines)
- Direct code reading: `renderer.js` lines 155–229 (startup restore), 1540–1555 (subscriber)
- Direct code reading: `.planning/phases/05-remember-explorer-state/05-01-SUMMARY.md`, `05-02-SUMMARY.md`, `05-VERIFICATION.md`
- Direct code reading: `styles/terminal.css` lines 1043–1057 (`.file-explorer-tree` overflow-y: auto)

### Secondary (MEDIUM confidence)
- Electron app lifecycle: `main.js` lines 182–190 (`before-quit` → `app-will-quit` IPC)
- DOM scroll behavior: `scrollTop`, `scrollHeight`, `clientHeight` — standard browser APIs, not library-specific

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — no new dependencies; existing infrastructure fully understood via code reading
- Architecture: HIGH — root cause analysis based on direct code tracing, not speculation
- Pitfalls: HIGH — derived from actual code paths, not generic advice

**Research date:** 2026-02-25
**Valid until:** 2026-03-25 (stable codebase; only invalidated by changes to FileExplorer.js or TerminalSessionService.js)
