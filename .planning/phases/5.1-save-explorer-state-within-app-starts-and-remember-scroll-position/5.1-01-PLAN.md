---
phase: 5.1-save-explorer-state-within-app-starts-and-remember-scroll-position
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/ui/components/FileExplorer.js
  - src/renderer/services/TerminalSessionService.js
autonomous: true
requirements: [EXPL-01, EXPL-03]

must_haves:
  truths:
    - "Explorer expanded folders survive app restart (cold start)"
    - "Explorer panel visibility survives app restart (cold start)"
    - "File tree scroll position is saved per-project and restored on project switch"
    - "File tree scroll position is restored after app restart"
    - "Scroll position is clamped to max if tree is shorter than saved position"
    - "Programmatic scroll during restore does not trigger a save-to-disk cycle"
  artifacts:
    - path: "src/renderer/ui/components/FileExplorer.js"
      provides: "scrollTop in getState, counter-based async restore in restoreState, debounced scroll listener, _isRestoring guard"
      contains: "_applyScrollTop"
    - path: "src/renderer/services/TerminalSessionService.js"
      provides: "skipExplorerCapture flag to prevent overwriting explorer state during terminal restore"
      contains: "_skipExplorerCapture"
  key_links:
    - from: "src/renderer/ui/components/FileExplorer.js"
      to: "src/renderer/services/TerminalSessionService.js"
      via: "_triggerSave on scroll events"
      pattern: "debouncedScrollSave"
    - from: "src/renderer/services/TerminalSessionService.js"
      to: "src/renderer/ui/components/FileExplorer.js"
      via: "getState() call guarded by _skipExplorerCapture"
      pattern: "_skipExplorerCapture"
---

<objective>
Fix explorer state being lost on cold-start app restart and add scroll position persistence to the file tree.

Purpose: Phase 5 saves/restores explorer state on project switches, but cold starts lose the state because `saveTerminalSessionsImmediate` is called during the terminal restore loop — at that moment FileExplorer.getState() returns empty state, overwriting saved data on disk. Additionally, scroll position is not persisted, so the file tree always jumps to the top.

Output: FileExplorer.js with scrollTop in getState/restoreState, counter-based async scroll restore, debounced scroll listener with _isRestoring guard. TerminalSessionService.js with _skipExplorerCapture flag to prevent overwriting explorer state during terminal restore.
</objective>

<execution_context>
@C:/Users/uhgde/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/uhgde/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-remember-explorer-state/05-01-SUMMARY.md
@.planning/phases/05-remember-explorer-state/05-02-SUMMARY.md
@.planning/phases/5.1-save-explorer-state-within-app-starts-and-remember-scroll-position/5.1-RESEARCH.md
@src/renderer/ui/components/FileExplorer.js
@src/renderer/services/TerminalSessionService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix cold-start overwrite and add _skipExplorerCapture guard in TerminalSessionService</name>
  <files>src/renderer/services/TerminalSessionService.js</files>
  <action>
Add a module-level flag `let _skipExplorerCapture = false;` to TerminalSessionService.js.

Export two functions:
- `setSkipExplorerCapture(value)` — sets the flag
- (the flag is read inside saveTerminalSessionsImmediate)

In `saveTerminalSessionsImmediate`, find the section where it calls `FileExplorer.getState()` and writes explorer state. Wrap that call in a guard:
```js
if (!_skipExplorerCapture) {
  const FileExplorer = require('../ui/components/FileExplorer');
  existingData.projects[currentProject].explorer = FileExplorer.getState();
}
```

When `_skipExplorerCapture` is true, the existing explorer state on disk is preserved as-is (the merge-before-write already loads it).

Add `setSkipExplorerCapture` to the module.exports.

This fixes the cold-start bug: renderer.js will set `_skipExplorerCapture = true` before the terminal restore loop and `_skipExplorerCapture = false` after it completes. This prevents the terminal restore's `saveTerminalSessions` calls from overwriting the saved explorer state with empty data.

Note: The renderer.js wiring of the flag around the restore loop will be done in Plan 02.
  </action>
  <verify>
    <automated>cd C:/Users/uhgde/source/repos/claude-terminal && npm test 2>&1 | tail -5</automated>
    <manual>Grep for _skipExplorerCapture in TerminalSessionService.js — should appear as declaration, guard, setter, and export</manual>
  </verify>
  <done>TerminalSessionService has _skipExplorerCapture flag and setSkipExplorerCapture export; when flag is true, saveTerminalSessionsImmediate preserves existing explorer state from disk instead of overwriting with live getState()</done>
</task>

<task type="auto">
  <name>Task 2: Add scrollTop to getState/restoreState, counter-based async restore, debounced scroll listener with _isRestoring guard</name>
  <files>src/renderer/ui/components/FileExplorer.js</files>
  <action>
**1. Add scrollTop to getState():**

In the existing `getState()` function, add `scrollTop` to the returned object:
```js
function getState() {
  const treeEl = document.getElementById('file-explorer-tree');
  return {
    expandedPaths: [...expandedFolders.keys()].filter(p => {
      const entry = expandedFolders.get(p);
      return entry && entry.loaded;
    }),
    panelVisible: isVisible,
    scrollTop: treeEl ? treeEl.scrollTop : 0
  };
}
```

**2. Add _isRestoring flag and _applyScrollTop helper:**

Add at module level: `let _isRestoring = false;`

Add helper function:
```js
function _applyScrollTop(scrollTop) {
  if (!scrollTop) return;
  requestAnimationFrame(() => {
    const treeEl = document.getElementById('file-explorer-tree');
    if (!treeEl) return;
    const maxScroll = Math.max(0, treeEl.scrollHeight - treeEl.clientHeight);
    treeEl.scrollTop = Math.min(scrollTop, maxScroll);
    // Delay clearing _isRestoring to let the scroll event from programmatic set pass
    setTimeout(() => { _isRestoring = false; }, 100);
  });
}
```

**3. Refactor restoreState() for counter-based async scroll restore:**

Replace the existing `restoreState` implementation with:
```js
function restoreState(savedState) {
  const { expandedPaths = [], panelVisible = true, scrollTop = 0 } = savedState;

  _isRestoring = true;

  // Panel visibility
  if (panelVisible && !isVisible) {
    show();
  } else if (!panelVisible && isVisible) {
    manuallyHidden = true;
    const panel = document.getElementById('file-explorer-panel');
    if (panel) panel.style.display = 'none';
    isVisible = false;
  } else {
    manuallyHidden = !panelVisible;
  }

  if (expandedPaths.length === 0) {
    render();
    _applyScrollTop(scrollTop);
    return;
  }

  let remaining = 0;
  for (const folderPath of expandedPaths) {
    try {
      if (!fs.existsSync(folderPath)) continue;
      if (!isPathSafe(folderPath)) continue;
      const entry = expandedFolders.get(folderPath);
      if (!entry) {
        remaining++;
        expandedFolders.set(folderPath, { children: [], loaded: false, loading: true });
        readDirectoryAsync(folderPath).then(children => {
          const e = expandedFolders.get(folderPath);
          if (e) { e.children = children; e.loaded = true; e.loading = false; }
          remaining--;
          render();
          if (remaining === 0) _applyScrollTop(scrollTop);
        }).catch(() => {
          remaining--;
          const e = expandedFolders.get(folderPath);
          if (e) { e.loaded = true; e.loading = false; }
          render();
          if (remaining === 0) _applyScrollTop(scrollTop);
        });
      } else if (entry && !entry.loaded && !entry.loading) {
        // Entry exists but not loaded — reload it
        remaining++;
        entry.loading = true;
        readDirectoryAsync(folderPath).then(children => {
          entry.children = children; entry.loaded = true; entry.loading = false;
          remaining--;
          render();
          if (remaining === 0) _applyScrollTop(scrollTop);
        }).catch(() => {
          entry.loaded = true; entry.loading = false;
          remaining--;
          render();
          if (remaining === 0) _applyScrollTop(scrollTop);
        });
      }
    } catch (e) { /* silently skip */ }
  }

  if (remaining === 0) {
    render();
    _applyScrollTop(scrollTop);
  }
}
```

Key difference from Phase 5's restoreState: counter-based tracking of async loads so scroll restore waits for all folder loads to complete.

**4. Add debounced scroll listener:**

In the `init()` function (or wherever listeners are attached), after existing listeners, add:
```js
const treeEl = document.getElementById('file-explorer-tree');
if (treeEl) {
  const debouncedScrollSave = debounce(() => {
    if (!_isRestoring) _triggerSave();
  }, 500);
  treeEl.addEventListener('scroll', debouncedScrollSave);
}
```

The `debounce` function is already imported from `../../utils/dom` in FileExplorer.js. Verify this import exists; if not, add it.

**Important:** The `_isRestoring` flag prevents scroll saves during programmatic restore. It is set to `true` at the start of `restoreState` and cleared in `_applyScrollTop` after a 100ms delay (letting the programmatic scroll event pass through the debounce window).
  </action>
  <verify>
    <automated>cd C:/Users/uhgde/source/repos/claude-terminal && npm run build:renderer 2>&1 | tail -3 && npm test 2>&1 | tail -5</automated>
    <manual>Grep FileExplorer.js for: scrollTop in getState return, _applyScrollTop function, _isRestoring flag, debouncedScrollSave listener, counter-based remaining in restoreState</manual>
  </verify>
  <done>FileExplorer.getState() includes scrollTop; restoreState uses counter-based async loading with scroll restore after all folders load; debounced scroll listener saves on user scroll but not during programmatic restore; _isRestoring flag prevents save-during-restore cycles</done>
</task>

</tasks>

<verification>
1. `npm run build:renderer` succeeds
2. `npm test` — all tests pass
3. Grep `_skipExplorerCapture` in TerminalSessionService.js — present as flag, guard, setter, export
4. Grep `scrollTop` in FileExplorer.js — present in getState return, restoreState destructure, _applyScrollTop
5. Grep `_isRestoring` in FileExplorer.js — present as flag, set in restoreState, checked in scroll listener, cleared in _applyScrollTop
6. Grep `debouncedScrollSave` in FileExplorer.js — present as scroll listener
</verification>

<success_criteria>
- TerminalSessionService exports setSkipExplorerCapture and guards FileExplorer.getState() call
- FileExplorer.getState() returns { expandedPaths, panelVisible, scrollTop }
- FileExplorer.restoreState() uses counter-based async restore and applies scrollTop after all loads
- Debounced scroll listener triggers _triggerSave, guarded by _isRestoring
- Build and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/5.1-save-explorer-state-within-app-starts-and-remember-scroll-position/5.1-01-SUMMARY.md`
</output>
